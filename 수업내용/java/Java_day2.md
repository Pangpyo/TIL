# 객체 지향 프로그래밍

날짜: 2023년 1월 17일

# 객체지향 프로그래밍이란?

## 객체지향 프로그래밍

### 객체지향 프로그래밍의 장점

- 신뢰성 높은 프로그래밍이 가능
- 추가/수정/삭제가 용이
- 재 사용성이 높다

### 현실 세계 객체, 클래스, 프로그램의 객체의 관계

- 현실의 객체가 갖는 속상과 기능은 추상화가 되어 클래스에 정의된다
- 클래스는 구체화 되어 프로그램의 객체가 된다
- 현실의 격체는 우리가 만지고 느낄 수 있는 것 > 실생활에 구체화 되어있는 내용
    - ex) 붕어빵과 붕어빵 틀
        - 붕어빵 틀은 Type, 붕어빵은 객체
- 현실의 객체가 갖는 속성과 기능은 추상화 되어 클래스에 정의된다
- 클래스는 구체화되어 프로그램의 객체가 된다

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled.png)

### 객체 생성과 메모리

- JVM의 메모리 구조

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%201.png)

- 객체의 생성과 메모리 할당

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%202.png)

- `Person` 이라는 클래스는 클래스 영역에 존재
- `main` 이라는 메서드 안에 있는 변수들이 스택 영역으로 들어감
- 변수가 선언한 `new` 값들이 힙 영역으로 들어감

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%203.png)

## 변수

### 위치에 따른 변수의 종류

- 변수의 종류
    - 타입에 따른 분류
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%204.png)
    
    - 선언 위치에 따른 분류
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%205.png)
    

### 인스턴스 멤버 변수의 특징

- 선언 위치 : 클래스 {}영역에 선언
- 변수의 생성 : 객체가 만들어 질 때 객체 별로 생성됨
    - 생성 메모리 영역 : heap
- 변수의 초기화 : 타입별로 default 초기화
- 변수에의 접근 : 객체 생성 후 (메모리에 올린 후) 객체 이름(소속)으로 접근
- 소멸 시점 : Garbage Collector 에 의해 객체가 없어질 때, 프로그래머가 명시적으로 소명시킬 수 없음

### 클래스 멤버 변수의 특징

- 선언 위치 : 클래스 {}영역에 선언되며 static 키워드를 붙임
    - static : 정적. 얌전하다라는 의미로 생각하면 좋음!
- 변수의 생성 : 클래스 영역에 클래스 로딩 시 메모리 등록
    - 개별 객체의 생성과 무관
    - **모든 객체가 공유하게 됨(공유 변수라고도 불림)**
- 변수의 초기화 : 타입 별로 default 초기화
- 변수에의 접근 : 객체 생성과 무관하게 클래스 이름(소속)으로 접근
    - 객체를 생성하고 객체 이름으로도 접근은 가능하나 static에 부합한 표현은 아님
- 소멸 시점 : 프로그램 종료 시

### 지역 변수 & 파라미터 변수

- 선언 위치 : 클래스 영역의 {} 이외의 모든 중괄호 안에 선언되는 변수들
- 메서드, 생성자, 초기화 블록
- 변수의 생성 : 선언된 라인이 실행될 때
    - 생성 메모리 영역 : thread 별로 생성된 stack 영역
- 변수의 초기화 : 사용하기 전 명시적 초기화 필요
- 변수에의 접근 : 외부에서는 접근이 불가하므로 소속 불필요
    - 내부에서는 이름에 바로 접근
- 소멸 시점
    - 선언된 영역인 {}을 벗어날 때

## 메서드

### 메서드 정의와 필요성

- 메서드란?
    - 현실의 객체가 하는 동작을 프로그래밍 화
    - 어떤 작업을 수행하는 명령문의 집합
- 메서드를 작성하는 이유
    - 반복적으로 사용되는 코드의 중복 방지
    - 코드의 양을 줄일 수 있고 유지보수가 용이함

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%206.png)

### 메서드 호출

- 메서드를 호출할 때는 메서드의 선언부에 맞춰 호출해야 함
    - 메서드 이름 : 반드시 동일
    - 파라미터 : 선언된 파라미터의 개수는 반드시 동일, 타입은 promotion 적용 가능
- 메서드 접근
    - 멤버 변수와 마찬가지로 static 또는 non static 상태를 구분해서 호출
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%207.png)
    
    - 가장 중요한 것은 호출하려는 멤버가 메모리에 있는가?
        - 메모리에 있으면 호출 가능
            - static member > 언제나 메모리에 있음 : 클래스 로딩 시 자동 등록
        - 메모리에 없으면 호출 불가 - 먼저 메모리에 로딩 후 사용해야 함
            - instance member > 객체 생성 전에는 메모리에 없음 : 객체 생성 시 모든 일반 멤버들은 메모리에 생성

### 클래스 멤버와 일반 멤버간의 참조와 호출

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%208.png)

### 메서드 호출 스택

- 스택
    - FILO, 선입후출의 구조
- 메서드 호출 스택
    - 각각의 메서드 호출시마다 메서드 동작을 위한 메모리 상자를 하나씩 할당
    - A 메서드에서 새로운 메서드 B호출시 B실행을 위한 메모리 상자를 쌓음
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%209.png)
    

### 기본형 변수와 참조형 변수★★★★★

- 메서드 호출 시 파라미터로 입력된 값을 복사해서 전달
- Java는 call by value!! Value의 정체는?

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%2010.png)

## 메서드 오버로딩★★★★★

### 메서드 오버로딩

- overloading : 동일한 기능을 수행하는 메서드의 추가작성
    - 일반적으로 메서드 이름은 기능별로 의미 있게 정함
    - 동일한 기능을 여러 형태로 정의해야 한다면?
- 메서드 오버로딩의 장점
    - 기억해야할 메서드가 감소하고 중복 코드에 대한 효율적 관리 가능

### 메서드 오버로딩 방법

- 메서드 이름은 동일
- 파라미터의 개수 또는 순서, 타입이 달라야 할 것
    - 파라미터가 같으면 중복 선언 오류
- 리턴 타입은 의미 없음

## 생성자

### 생성자

- 객체를 생성할 때 호출하는 메서드 비슷한 것
    - new 키워드와 함께 호출하는 것
        - `Person person1 = new Person();`
        - 일반 멤버 변수의 초기화나 객체 생성 시 실행돼야 하는 작업 정리
- 작성 규칙
    - 메서드와 비슷하나 리턴 타입이 없고 이름은 클래스 이름과 동일
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%2011.png)
    

### 생성자의 종류

- 기본 생성자
    - 그 동안 예제에서는 생성자를 작성하지 않았음
    - 기본 생각자의 형태는 파라미터가 없고 구현부가 비어있는 형태
    - 생성자 코드가 없으면 컴파일러가 기본 생성자 제공
        - 생성자 코드가 하나라도 있으면 컴파일러가 기본 생성자를 제공하지 않음
- 파라미터가 있는 생성자
    - 생성자 목적이 일반 멤버 변수의 초기화 > 생성자 호출 시 값을 넘겨줘서 초기화
    - 주의! 파라미터가 있는 생성자를 만들면 기본 생성자는 추가되지 않는다.
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%2012.png)
    

## this의 용법

### this

- 클래스 내부에서만 사용 가능
- 참조 변수로써 객체 자신을 가리킴
    - 참조변수를 통해 객체의 멤버에 접근했던 것처럼 this를 이용해 자신의 멤버에 접근 가능
- 용도
    - 로컬 변수와 멤버 변수의 이름이 동일할 경우 멤버 변수임을 명시적으로 나타냄
    - 명시적으로 멤버임을 나타낼 경우 사용
- this는 객체에 대한 참조
    - 따라서 static 영역에서 this 사용 불가

### this()

- 메서드와 마찬가지로 생성자도 오버로딩 가능
    - 객체 생성 시 필요한 멤버변수만 초기화 진행 > 생성자 별 코드의 중복 발생
    - 한 생성자에서 다른 생성자를 호출 할 때 사용
- 반드시 첫 줄에서만 호출이 가능

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%2013.png)

- 

```java
public static void main(String[] args) {
	String sentence1 = "김싸피";
	String sentence2 = "김싸피";
	String sentence3 = new String ("김싸피");
	String sentence4 = new String ("김싸피");
	
	int num1 = 10;
	int num2 = 10;
	
	if (sentence1 == sentence2) {
		System.out.println("1. 같음");
	}
	else {
		System.out.println("1. 다름");
	}
	
	if (sentence2 == sentence3) {
		System.out.println("2. 같음");
	}
	else {
		System.out.println("2. 다름");
	}
	
	if (sentence3 == sentence4) {
		System.out.println("3. 같음");
	}
	else {
		System.out.println("3. 다름");
	}
}
```

![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20e477006c118b407aa5f84039b83d6ed4/Untitled%2014.png)