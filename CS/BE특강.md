# CS와 함께하는 BE이야기

## 서버의 성능이란?
### 서버는 구조를 바꾸기 어렵다.
* 서버의 구조가 바뀌면, 코드가 바뀐다. 그동안 짠 코드는?
* DB구조가 바뀐다. 운영중에는 바꾸기 힘들고, 기존의 데이터는 어떻게 해야할까?
* 처음부터 잘 만드는 것이 중요하다.
### TPS
* Transaction Per second
* 서버가 초당 처리한 사용자 요청의 수. 이를 통해 서버의 성능을 판단할 수 있다. 
### 동시접속자 vs TSP
* 동시접속자 : 접속 사용자중 현재 시스템을 사용하는 사용자
* 부하사용자 : 현재 작업을 하여 결과를 기다리는 사용자
### Saturation Point/w TPS
* 서버가 늘어날 수록, 서버가 가질 수 있는 TPS의 한계가 있다.
* 서버를 늘린다고 무조건 서버 TPS가 늘어나진 않는다.
### TPS가 높은면 다일까?
* 자원의 사용량을 체크해야한다.

## 서버의 요청 처리하기
### 서버는 어떻게 요청을 처리할까?
* 장고, 스프링 등에서는?
* Q : 원격 프로세스는 직접 통신할 수 있나요?
  * 할 수 없다. 그렇기에 소켓을 통해서 간접적으로 통신한다.
    * TCP면 스트림 소켓, UDP면 데이타그램 소켓이 오겠다.
    * port : 통신에서 애플리케이션이 상호구분을 위해 사용하는 번호
    * socket : 네트워크상에서 돌아가는 두 프로그램간 양방향 통신의 엔드포인트.(똑같은 서버로 서로 다른 요청이 들어올 떄, 어떻게 구분할 것인가?)
* 기본적으로, 대부분의 서버는 request가 올 시, 그에 해당하는 프로세스/thread가 있어야한다. 하지만 진짜 각 요청마다 만들면, 컨텍스트 스위칭이 과도하게 발생한다. 
### Cast Study : SpringBoot : Tomcat
* 사용자의 요청을 처리할 스레드를 미리 만들어 놓고, 요청이 들어올 떄 마다 스레드를 처리하는 방식을 사용한다.
* 쓰레드풀
  * 한 번에 처리할 수 있는 스레드의 개수가 한정되어 있기에, TPS가 한정되는 이유가 되기도 한다.
### c10k prob
* 한번에 10000개의 클라이언트를 동시에 처리할 수 있는 네트워크 I/O를 설계할수있나?
* 리눅스는 모든게 파일이다 : 소켓도 파일이다!
* 리눅수는 한번에 열 수 있는 파일디스크럽터의 개수가 정해져있다. (soft, hard), 필요에 따라 soft리미트를 조절
### Case Study : MySQL Connection
* MySQL또한 커넥션별로 소켓을 열어서 관리한다. max_connection 제한이 걸려있다. 이걸 높이기 위해 이 soft리미트를 조절해야할 수도 있다.
### 파일 열어보기
* python은 `open()`, 자바는 `new File()`... 여러 파일을 여는 것도 문제 없다.
* 소켓도 파일이다. 하나의 스레드로 파일을 관리하는것처럼, 소켓도 관리할 수 있지 않을까?
* I/O Multiplexing과 같이!
### Case Study - Redis
* 레디스가 싱글쓰레드로 할 수 있는 이유가, I/O 멀티플렉싱을 사용하기 떄문(이벤트 루프)
## TCP/UDP
### HTTP
* W3상에서 정보를 주고받을 수 있는 프로토콜. 주로 TCP를 사용한다. HTTP/3부터는 UDP 사용
### TCP와 UDP 차이
* TCP : 신뢰성 있는 통신
* UDP : 신뢰성 없지만 빠르다...
이게 다일까?
### TCP - 더 빠르게 할 수 없을까?
* 3-way handshake 사용.. 느리다!
* HTTP/1.0 : html, css, js... handshake를 3번이나 해야한다! 새로고침마다 3회를 했다.
* HTTP/1.1 : 비표준 헤더를 통해 한번에 html, css, js를 보냈다. 웹 캐시 적용시 0~1회..
* 이렇게 개선 해도, 같은 서버의 다른 주소에 대해 3회의 RTT가 발생 해야했다.
### TCP Fast Open
* 서버가 syn+ack시에 cookie를 같이 보낸다!
* 이후 클라이언트가 syn, 쿠키, 요청을 한번에 보내버린다. 이렇게 한다면, handshake를 완화할 수 있다. (클라이언트의 ack 전에 응답을 보낼 수 있다.)
### UCP - 신뢰성이 없는데 왜 쓸까?
* UDP를 쓰는 이유 : 신뢰성을 약간 희생해도 될 떄?, TCP를 사용 할 수 없는 환경, HTTP/3같은 경우?
* DHCP에서 UDP를 사용하는 이유가 무엇일까?
### DHCP
* DHCP 서버에 IP를 할당을 요청한다.(DHCP서버의 위치를 모르기에, 브로드캐스트한다)
* TCP통신은 1:1로 이루어진다! (유니캐스트이다.)
* DHCP 서버와의 통신은 브로드캐스트이기에, UDP일 수밖에!!
### TCP, 충분히 빠른데 왜 HTTP/3는 UDP?
* TCP가 너무 오래됐다. 1981년 등장... 수많은 신뢰성을 위한 기법들. 지금 상황에 필요하지 않거나, 오히려 비효율적인 방법들. 너무 예전 스펙이다.
* 그럼에도 불구하고 UDP를 사용하기에는 문제가 있었다. 신뢰성 문제!
### OSI 7계층
* 왜 이렇게 계층을 가지는가...?
* 구현의 용이함(각자의 레이어는 각자의 역할에 충실)
* 서로 완전 독립적으로 운용 가능. 다른 레이어에 대해 신경쓰지 않아도 된다.
* HTTP는 7계층, tcp는 4계층.. 사실 HTTP는 TCP에 의존적인것은 아니다
### QUIC
* 그래서, 레이어구조니까 QUIC, UDP, HTTP를 쌓았다
* 브라우저가 TCP인지 UCP인지 어떻게 아나..? 같은 문제들이 있긴하다
  * 브라우저의 해결법 : TCP UDP요청을 동시에 보내는 등
## 서버 늘리기
### Scale Out, Scale Up
* Scale Out : 서버 대수 늘리기
* Scale Up : 서버의 사양 늘리기

### 네트워크 아키텍처에서 중요한 요소, SPOF
* Single point of failure
* 시스템 구성 요소중에서, 하나의 장애가 전체 장애로 이어지는 지점
* 그렇기에 scale out으로 가는 경우가 기본이다.
  * 하지만 무작정 서버가 많아지면 네트워크 이슈로 인해 오히려 문제가 생길 수도!
  * GPU 사용 등이 있을떄는 스케일아웃이 너무 비쌀수도..
### Case Study : 이미지 처리 서버 설계
* 구글 드라이브나 Naver MYBOX와 같은 클라우드 스토리지를 만든다고 가정하다.
* 공통적으로 이미지에 대한 썸네일을 추출한다. (OCR 등으로 텍스트 검색이 가능하게 만들기도)
* 고용량 이미지가 들어오거나, OCR작업이 포함된 경우 GPU 등의 자원이 필요할 수도 있다.
* 그래픽카드는 비싸다.. 이걸 scale out하기에는 비용 문제가..?
* 썸네일 추출 작업을 수행하는 API의 호출 비율은 얼마나 될까?
  * 공유, 다운로드, 복사, 조회, 폴더생성, 이름 변경, 업로드... 이 중에서 썸네일 추출 작업의 비중이 높진 않을것이다.
* 썸네일이 바로 나올 필요가 있을까?
  * 썸네일이 조금 늦게 나오더라도 크게 지장 없을것이다.
* GPU는 API 호출 빈도에 비해 자원을 많이 먹고, 실시간성이 떨어진다.
* 그렇다면, 컴포넌트를 분리해서 이미지 프로세스 서버를 따로 분리하자.
* 이렇게 하면 요청이 많이 들어오는 메인서버는 scale out해도 gpu를 사용하지 않기에 비용 문제가 적어진다.
* 하지만 이미지 처리는 많은 시간이 걸린다. 그렇다면 메인서버와 이미지 프로세스 서버에서 시간 차이가 날 수 있다.
  * 이미지 프로세스 서버 입장에선, 처리가 끝나지도 않았는데 이미지가 계속 오게된다...
* 서버의 구조상, 대기하고 있는 요청은 한계가 있고, 요청의 유실 위험이 있다.
* 잘 생각해보면, 요청에 대한 응답을 꼭 기다릴 필요가 없다.
  * 이런 조건을 만족하는 프로세스와 프로세스 사이의 통신 방식이 있을까?
### Named Pipe
* IPC 기법중 하나, 특수파일은 Pipe 파일을 활용한 단방향 통신 기법
### Message Queue
* 이걸 메세지 큐 형식으로 바꿔서...처리한다면?
* ex: 카프카, 레빗 MQ...
### MSA?
* 자원 관리에 필요하다면 하지만, 너무 쪼개면 관리포인트가 늘어나는 위험성이 있다.
## 메모리
### 메모리 계층성
* 하드 > 램 > 캐시 > 레지스터... 성능은 점점 좋아지고 비용도 점점 늘어난다.
### case study: MySQL Buffer Pool
* SSD를 쓰면 DBMS가 빨라질까? 버퍼사이즈가 커질수록 SSD와 HDD의 성능 차이가 적어진다.
* 그렇기에 메모리에 대한 고민을 많이 할 필요가 있다.
### case study: Java Boxing Type
* 자주 호출되는 데이터가 있다면, Map/Set이나 List형식의 캐시도 좋은 전략이다. 꼭 redis같은 캐시를 쓸 필요는 없다.
* 혹은 로컬캐시 라이브러리도 많이 있다.
### Cache Locality
* 시간 지역성 : 최근에 참조된 주소의 내용은 금방 다시 참조된다.
* 공간 지역성 : 방문한 값의 주변 값들은 참조될 가능성이 높다.
  * 주변 값이란?? 메모리 주소가 가까운 값. 페이징으로 메모리를 관리하고, 기본적으로 4kb씩 참조한다.
### Case Study: MySQL 0 Clustered Index
* MySQL은 PK값 기반으로 물리적으로 연속해서 저장한다. 그렇기에 PK 기반의 쿼리는 공간 지역성을 적용받아, 성능 향상이 이루어진다.
  * 그렇기에 클러스터형 인덱스를 가장 먼저 고려해야한다.
* 새로운 데이터를 삽입하는데, 기존에 존재하던 PK 값 사이에 존재한다면?
  * 물리적으로 순차 저장을 해야하므로, 모든 값들이 물리적 재배치가 이루어져야한다. 많은 오버헤드가 생긴다.
* 이렇게 된 이유는, MySQL은 읽기를 위해 쓰기 성능을 약간 희생간 구조인 것이다. 어차피 읽기의 비중이 보통 높으니까!
* 꼭 캐싱의 주체가 값이어야하는가?
### Case Study: JVM Warm Up
* 자바 코드 > 바이트코드로 컴파일 > JVM에 적재
* 자주 호출되는 함수는 번역해준 것을 재활용 할 수 없을까?
* JIT, 자주 호출되는 부분은 캐싱을 하자!
  * JVM 네이티브 메모리 영역의 Code Cache 영역에 캐싱
  * 자주 호출되는 함수의 성능 향상
* 그러면, 처음부터 자주 호출되는 API를 강제로 호출시키면?
  * 사용자가 호출할 때는 이미 캐싱이 되어있다. 이것이 JVM Warm Up
    * 하지만 JVM warm up 자체가 서비스 장애의 문제가 되기도.

## DB 살펴보기
### DB 내부 구조
* 클라이언트와 통신, 인증, 보안을 담당하는 부분
* 쿼리에 대한 물리적 처리를 하는 부분 : 스토리지 엔진
  * 대표적으로 MySQL은 스토리지 엔진을 교체 가능. 현재는 InnoDB 사용...
### Case Study: Index
* 일단은 DB에서 값을 빠르게 찾을 수 있도록 트리 형식으로 저장하는 구조체.
* B tree로 이루어짐
### Case Study: MySQL memory
* created-at을 기준으로 정렬한다면?
* 인덱스에 created-at이 있냐에 따라 달라진다.
* 인덱스가 걸려있다면, 해당 조건을 만족하는 첫 값을 찾고 쭉 스캔한다.
* 걸려있지 않다면, order by 조건을 제외하고 쿼리 수행 후, 다시 정렬한다.(이 임시 테이블이 메모리에 올라간다(조인 등에서도 이 임시테이블이 메모리에 올라간다))
  * 데이터가 너무 많아, 메모리에 올라갈 수 없다면... 문제가 생긴다.
  * 이 때 외부정렬을 사용해야한다.
### External sort
* 램이 2gb고, 데이터가 16기가라면?
  * 16gb의 데이터에 대해, 2gb씩 나누어 메모리를 추가로 사용하지 않는 데이터를 정렬한다.
  * 이후 2gb의 데이터를 8토막내어서 이에 대해서 머지소트를 수행한다.
* 하지만 이 경우, 램에 올리고 내리기 위한 I/O가 매우 많이 발생한다.
* 그렇기에 인덱스를 거는 것이 중요하다... 서비스에서 요구하는 order by, groupby 조건에 따라!!

### JPA 왜쓸까..?
* 예전 DB는 서버가 아닌, DB에 부하를 주는 방식으로 발전해왔다.
  * optimaizer hinting 등... 쿼리를 정교하게 짰어야했다.
* 이제는 서버 성능 자체가 올라갔기에, application이 부하를 맡아도 큰 문제가 발생하지 않게 되었다. 이제는 app에 부하를 주는 방식으로 발전해보자.
* 그렇게 해서 JPA가 나오게 되었다. 
* 통계성 쿼리에는 직접 튜닝하는것이 좋을 수 있다.

### CS 열심히하자!!
* 암기보단 흐름에 대한 이해를 하자.
* 적용 방식을 고민해보자.
* 과목 단위가 아닌, 연계하여 이해하자.
