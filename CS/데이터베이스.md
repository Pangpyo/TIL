# 데이터베이스
* 데이터베이스는 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음.
## 데이터베이스의 기본
### 데이터베이스의 구성 요소
* 엔티티, 릴레이션, 속성, 도메인, 필드와 레코드
### 키
* 기본키
  * 자연키, 인조키
* 외래키
* 후보키 : 기본키가 될 수 있는 후보.유일성과 최소성을 갖추어야 한다
* 대체키 : 후보키가 두 개 이상인 경우 기본키를 제외한 나머지
* 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

### ERD의 중요성
* 데이터베이스를 구축할 때 기초적인 뼈대 역할을 한다.
* 시스템 요구사항을 기반으로 작성되며, 설계도 역할을 한다.
* 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용하다.

## 정규화
* 이상현상을 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 분리하는 과정
### 정규형 원칙
* 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고, 자료의 중복성은 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 각각의 릴레이션은 독립적으로 표현이 가능해야한다
### 제1 정규형
* 모든 도메인이 더 이상 분해될 수 없는 원자값으로 구성되어야 한다

### 제2 정규형
* 제1 정규형을 만족하는 릴레이션에서, 부분 함수의 종속성을 제거한 형태를 말한다.
* 부분함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다.

### 제3 정규형
* 제2 정규형이며 모든 속성이 이행적 함수 종속을 만족하지 않는 상태를 말한다.
* 이행적 함수 종속이란 A -> B가 와 B -> C가 존재하면 A -> C 가 성립하는데, 이때 C가 A에 대해 이행적 함수 종속이 되었다고 말한다.

### 보이스/코드 정규형
* 제 3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말한다.
  * 결정자 : X -> Y일 때, X는 결정자, Y는 종속자이다

## 트랜잭션
* 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
### 원자성
* 트랜잭션 안의 작업이 모두 수행되거나 되지 않았거나 보장되어야한다.
### 일관성
* 데이터베이스 안의 모든 데이터는 허용된 방식으로만 변경되어야한다
### 격리성
* 트랜잭션 수행 시 서로 끼어들지 못하는 것
### 무결성
* 데이터의 정확성, 일관성, 유효성을 유지하는 것
  * 개체 무결성, 참조 무결성, 고유 무결성, NULL 무결성

### 파티셔닝과 샤딩
* 테이블이 커질수록 성능이 감소할 것이다. 이를 위해 데이터베이스를 분리하는 방법이 파티셔닝과 샤딩이다.
* 파티셔닝 : 매우 큰 테이블을 여러개의 테이블로 분할하는 작업. MySQL에서 자체적으로 지원한다.
  * 수평 파티셔닝 : 테이블의 각 행을 다른 테이블에 분산시키는 것. 리스트 파티셔닝, 레인지 파티셔닝, 해쉬 파티셔닝 등이 있다.
  * 수직 파티셔닝 : 테이블의 일부 열을 빼내는 형태. 정규화도 수직 파티셔닝과 관련있는 과정이라고 볼 수 있다. 다만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정이다.
* 샤딩 : 동일한 스키마를 가진 여러대의 데이터베이스 서버들에 데이터를 작은 단위로 분산 저장하는 기법. 수평 파티셔닝의 일종이라 할 수 있다.

## 데이터베이스의 종류
### RDBMS(관계형 데이터 베이스)
* 행과 열을 가지는 표 형식의 데이터를 저장하며, 서로 관련된 데이터 지점에 대한 접근을 저장 및 제공하는 데이터베이스 유형
### NoSQL
* Not only SQL, SQL이 아닌 데이터베이스. MongoDB와 Redis가 대표적

## 인덱스
* 데이터베이스에서 데이터를 빠르게 찾을 수 있는 장치. 책의 찾아보기(인덱스)와 같다. 조회 속도를 크게 향상시킨다.
### 인덱스 사용시 주의점
* 인덱스는 비용이다. 인덱스를 사용시 삽입, 수정, 삭제시의 비용이 증가하므로 주의해야한다.
* DB크기의 10%정도의 추가 공간이 필요하다
* 인덱스 생성 자체에도 시간이 걸린다.

## 조인
* 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물로 만드는 것.
* inner join : 두 행이 모두 일치하는 부분만 표기
* left outer join : 왼쪽테이블의 모든 행이 결과 테이블에 표기
* right outer join : 오은쪽 테이블의 모든 행이 결과테이블에 표기
* full outer join : 두 개의 테이블을 기반으로 조인조건에 만족하지 않는 행까지 모두 표기

# 심화 질문

## Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
* 기본키 : 데이터를 구분하기 위한 키. 두 개 이상의 필드가 합쳐져서 기본키가 될 수도 있으며, 중복된 값이거나 null일수 없다. 인위적으로 만든 인조키와 자연적으로 있던 자연키가 있다.
* 후보키 : 기본키로 사용 할 수 있는 필드(의조합). 유일해야하고, null일수 없다.
* 슈퍼키 : 레코드를 고유하게 식별할 수 있는 하나 이상의 속성. 후보키를 포함하며, 유일성을 위해 필요하지 않는 필드가 포함 될 수 있다.
* 외래키 : 다른 테이블의 기본키를 참조하여 테이블간의 연관 관계를 설정하는 키.
* 유일키 : 테이블 내의 레코드를 유일하게 식별할 수 있는 속성. null값을 허용한다.
### 기본키는 수정이 가능한가요?
* 가능하지만, 수정을 하게 된다면 데이터 무결성에 영향을 줄 수도 있다.
### 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
* 가능한 후보키중에 하나를 클러스터형 인덱스로 지정한다. 만약 후보키가 없다면, InnoDB가 자체적으로 키를 생성하여 클러스터형 인덱스를 생성한다.
### 외래키 값은 NULL이 들어올 수 있나요?
* 가능하다.
### 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
* 데이터의 삽입과 수정시에는 UNIQUE 조건을 검사하기 위해 추가적인 시간이 소요된다. 또한 UNIQUE 인덱스 관리를 해야하기에 삽입, 수정, 삭제시에 시간이 소요된다. 하지만 검색시에는 UNIQUE 인덱스를 기반으로 더 빠르게 검색이 가능하다.

## RDB와 NoSQL의 차이에 대해 설명해 주세요.
* RDB : 데이터가 구조화되어있고, SQL을 사용한다. 데이터의 무결성이 있다.
* NoSQL : 다양한 데이터 저장 방식이 있다. 테이블간 관계를 정의하지 않고, 스키마 변경이 유연하여 빠르게 변화하는 요구사항에 적합하다. 또한 데이터 확장성이 높다.
### NoSQL의 강점과, 약점이 무엇인가요?
* 강점 : 확장성, 유연성, 대용량 데이터 처리
* 약점 : 데이터 무결성, 표준화되지 않은 쿼리 언어, 복잡한 쿼리 처리에 부적합함
### RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
* RDB는 데이터가 구조화되어있고, 데이터의 무결성을 엄격하게 지킨다. 이러한 과정에서 부하가 많이 걸릴 수 있고, 테이블이 많아지면 테이블간 Join을 많이 하게 되므로 속도가 느려질 수 있다.
### NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.
* Redis를 사용하였다. 키-밸류 기반으로 더 빠른 데이터 저장 및 조회가 가능하고, 인메모리 DB의 특성을 이용해 캐싱 및 메시지큐로 사용 가능했다.

## 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
* 트랜잭션 : 데이터베이스에서 하나의 논리적인 작업의 단위. 여러개의 연산이 포함 될 수 있다.
* ACID : 데이터 무결성을 위한 4가지 기본 속성
  * Atomicity(원자성) : 트랜잭션의 모든 연산은 전부 실행되거나, 그렇지 않아야한다.
  * Consistency(일관성) : 트랜잭션 실행 전 후로 데이터베이스가 일관된 상태를 유지해야한다.(트랜잭션은 데이터베이스가 허용하는 조건을 만족해야한다)
  * Isolation(독립성) : 독시에 여러 트랜잭션이 실행될 때, 각 트랜잭션은 다른 트랜잭션의 연산으로부터 독립적이어야 한다.
  * Durability(영속성) : 트랜잭션이 성공적으로 완료되면, 해당 결과는 영구적으로 데이터베이스에 남아야하며, 시스템 장애가 발생하더라도 유지되어야한다.
### ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
* 트랜잭션 종료 후 커밋을 통해 해당 커밋의 로그를 저장한다.
### 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
* 작업이 한번에 반영되야만 할 때. 여러 쓰기 작업이 동시에 이루어질 때, 중간에 작업을 멈추면 이전에 실행한 작업도 모두 취소해야한다면 트랜잭션을 사용 할 수 있다.
### 읽기에는 트랜잭션을 걸지 않아도 될까요?
* 읽기 작업은 데이터베이스를 변경하지 않는다. 그렇기에 많은 경우에 트랜잭션이 필요 없지만, 몇 몇 경우에 읽기작업에도 트랜잭션이 필요하다. 예를 들어 한 작업 안에서 동일한 데이터를 두 번 이상 읽어야하고, 그 데이터가 같아야 하는 경우에 필요하다. 또한 여러 개의 데이터를 읽을 때, 해당 데이터들이 동일한 시점의 데이터여야 하는 경우에도 트랜잭션이 필요하다.

## 트랜잭션 격리 레벨에 대해 설명해 주세요.
* Read Uncommitted : 아예 격리가 되지 않는 레벨
* Read Committed : 커밋된 데이터만 읽기 가능
* Repeatable Read : 선행 트랜잭션이 참조하는 모든 행에 대해 후행 트랜잭션이 갱신하거나 삭제 할 수 없다.
* Serializable : 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때 까지 후행 트랜잭션이 갱신하거나 삭제, 새로운 레코드를 삽입할 수 없다.
### 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
* 설계철학과 목표, 기술적 제약 등의 문제로 모두 구현하지 않은 경우도 있다. 예를 들어 MySQL은 모두 구현하고, 오라클은 Read Uncommited는 거의 필요가 없기 때문에 구현하지 않고 Repeatable Read는 Serializable이 효과적으로 구현되어 지원하지 않는다.
### 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
* Redo Log : DB 장애시 복구에 사용한다. 영속성을 위해 필요하다. Buffer Pool에 저장되어있던 데이터의 유실을 방지하기 위해 사용한다. 데이터 변경시 모든 것을 기록한다.
* Undo Log : 트랜잭션이 롤백 되거나, 다른 트랜잭션이 이전의 데이터를 읽어야하는 작업을 수행 할 때 필요한 원래 데이터를 제공한다.
### 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
* 데이터베이스에서 CRUD의 기본적인 작업을 수행하는 소프트웨어 구성 요소. 데이터의 저장, 접근 방식을 결정한다.

## 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
* 데이터베이스에서 특정 필드에 대해 빠른 검색이 필요할 때 사용하는 기술. 컬럼에 대해 정렬한 후 별도의 메모리 공간에 물리적 주소와 함께 저장한다.
### 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
* 데이터베이스 수정을 하는 경우, 인덱스도 그에 맞게 수정을 해야한다. 인덱스를 읽기만 하는 경우에 인덱스는 효과적이지만 그렇지 않은 경우에는 오히려 성능이 낮아질 수 있다.
### 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
* 인덱스에서 사용하지 않기로 한 값은 인덱스 유지 관리 정책에서 제외된다. 해당 값의 변경은 인덱스의 성능에 영향을 주지 않는다. 그렇기에 자주 수정되는 컬럼은 인덱스에서 제외하는것도 전략이 될 수 있다.
### ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
* ORDER BY : 인덱스가 없는 경우에는 모든 행을 스캔하여 주어진 열에 대해 정렬을 수행한다. 인덱스가 있고 ORDER BY 조건이 인덱스의 정렬조건과 같은 경우, 이미 정렬되어 있으므로 인덱스를 사용하여 그대로 결과를 반환한다. 
* GROUP BY : 인덱스가 없는 경우 모든 행을 스캔하고, 그룹화 할 컬럼의 고유 값을 찾는다. 그 후 집계합수를 적용한다. 인덱스가 있는 경우, GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 같은 경우 사용 할 수 있다.
### 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
* 기본키는 자동으로 클러스터형 인덱스가 생성된다. 클러스터형 인덱스는 테이블의 레코드를 물리적으로 정렬한다. 하지만 일반 인덱스는 정렬된 컬럼에 따라, 물리 주소를 따로 가지고 있다.
### 그렇다면 외래키는요?
* 외래키도 인덱스를 사용할 수 있다. 인덱스를 사용하는 경우 JOIN의 성능이 향상된다.
### 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
* 클러스터형 인덱스는 물리적 저장에 영향을 미친다. 그 외에는 그렇지 않다.
* 클러스터형 인덱스가 없는 경우 순서를 지정하지 않고 힙에 저장된다. 클러스터형 인덱스가 존재하는 경우 보통 해당 키에 따라 재정렬되며, 보통 기본키가 그 역할을 한다.
### 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
* 몽고DB는 인덱스를 가지고 있다. Hash, TTL index 등 다양한 인덱스를 제공한다. redis는 get작업은 이미 O(1)의 복잡도를 가지므로 인덱스로 필요치 않고, 보조키에서는 해시 인덱스를 구축 할 수 있다.
### (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
* 인덱스를 사용하지 못한다. 반대로 A조건만 사용하고 B조건을 사용하지 않는 경우에는 가능하다.

## RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.
* 레플리케이션 : 데이터를 여러 위치에 복제하여 저장하는 방식. 보조 서버에서 읽기를 처리하여 주 서버의 부하를 줄인다. master-slave 구조로 구성된다. 수직적인 구조로 구축한다. master가 다운된 경우 복구가 까다롭다.
* 클러스터링 : 여러 대의 DB서버가 수평적인 구조로 관리하는 방식. 여러 서버가 요청을 나눠 처리함으로써 성능을 향상시킨다. 노드들간의 데이터가 동기화된다. 1개 노드가 죽어도 다른 노드가 살아있어 시스템을 장애없이 운영할 수 있다.

### 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
* 2-Phase Commit (2PC) : 준비단계에서 모든 참여 노드가 트랜잭션을 커밋할 준비가 되어있는지 확인하고, 두 번째 단계에서 모든 노드가 준비되었다면 커밋을 진행한다.
* 3-Phase commit : 2PC에서 중간 단계에 사전 커밋단계를 거친다. 이를 통해 트랜잭션 상태를 보다 명확하게 파악할 수 있도록 한다.
* SAGA 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리한다. 중간에 실패가 발생한 경우, 보상 트랜잭션을 통해 일관성을 유지한다.
### 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
* 데이터 동기화가 완료되기 전까지 슬레이브에서의 읽기 요청을 제한하거나, 마스터로 리다이렉션하여 일관성을 유지 할 수 있다.
### 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
* 두개 이상의 트랜잭션이 특정 자원(데이터)를 점유 한 채 다른 트랜잭션이 점유한 자원(데이터)를 요구하면 데드락이 발생한다.
* 예방 : 각 트랜잭션이 실행되기 전 필요한 모든 자원을 락한다. 속도가 느려 질 수 있다.
* 회피 : 
  * Wait Die : 다른 트랜잭션이 점유한 자원을 요청 할 때, 자신이 먼저 들어왔다면 기다리고 그렇지 않다면 포기하고 나중에 다시 요청한다. 점유 대기 조건을 만족하지 않게한다.
  * Wound-Wait : 먼저 들어온 트랜잭션이면 데이터를 선점하고, 그렇지 않다면 대기한다. 비선점을 만족하지 않게 한다.
### 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
* 샤딩 : 테이블을 여러 서버에 분산시켜 저장하는 방식. 
* 하나의 데이터베이스가 너무 커지면 샤딩을 사용해서 분산을 할 수 있다. 거기에 안정성을 위해 샤딩한 각각의 DB서버에 레플리케이션을 적용할 수 있다.

## 정규화가 무엇인가요?
* 데이터베이스 수정, 삽입, 삭제 작업시의 이상현상을 방지하고 무결성과 일관성을 유지하기 위해 테이블을 분해해서 여러개의 테이블로 만드는 과정. 이상현상을 제거하고 무결성과 일관성이 있지만, JOIN연산으로 인한 응답 시간이 느려질 수 있다.
### 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
* 특정 속성에 해당하는 값이 없어 null을 입력해야 하는 삽입 이상
* 즉정 튜플 삭제시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 삭제 이상
* 튜플 생신시 중복된 데이터의 일부만 갱신되어 일어나는 갱신 이상
### 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
* 제 1정규형 : 모든 컬럼이 원자값을 가진다. 각 컬럼에는 하나의 값만 가지게 된다.
* 제 2정규형 : 부분 함수 종속성을 제거한다. 즉 모든 비주요 속성이 기본키 전체에 대해서만 종속된다.
* 제 3정규형 : 이행 함수 종속성을 제거한다. 비주요 속성간에 종속성이 사라진다.
* 보이스코드 정규형 : 모든 결정자가 후보키가 된다. 후보키가 아닌 속성에 의해 결정되는 종속성을 제거한다.
### 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
* 정규화를 하면 데이터의 무결성과 일관성이 강해진다. 하지만 테이블이 분해됨으로써 구조가 복잡해 질 수 있고, join연산으로 인해 성능이 느려질 수 있다. 어떤 데이터에서 테이블 구조의 변경이 없고, 데이터의 수정이나 삭제가 잘 일어나지 않는다면 역정규화를 한 테이블이 성능상 유리할 수 있다.