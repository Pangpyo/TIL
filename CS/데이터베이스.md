# 데이터베이스
* 데이터베이스는 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음.
## 데이터베이스의 기본
### 데이터베이스의 구성 요소
* 엔티티, 릴레이션, 속성, 도메인, 필드와 레코드
### 키
* 기본키
  * 자연키, 인조키
* 외래키
* 후보키 : 기본키가 될 수 있는 후보.유일성과 최소성을 갖추어야 한다
* 대체키 : 후보키가 두 개 이상인 경우 기본키를 제외한 나머지
* 슈퍼키 : 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

### ERD의 중요성
* 데이터베이스를 구축할 때 기초적인 뼈대 역할을 한다.
* 시스템 요구사항을 기반으로 작성되며, 설계도 역할을 한다.
* 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용하다.

## 정규화
* 이상현상을 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 분리하는 과정
### 정규형 원칙
* 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고, 자료의 중복성은 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 각각의 릴레이션은 독립적으로 표현이 가능해야한다
### 제1 정규형
* 모든 도메인이 더 이상 분해될 수 없는 원자값으로 구성되어야 한다

### 제2 정규형
* 제1 정규형을 만족하는 릴레이션에서, 부분 함수의 종속성을 제거한 형태를 말한다.
* 부분함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다.

### 제3 정규형
* 제2 정규형이며 모든 속성이 이행적 함수 종속을 만족하지 않는 상태를 말한다.
* 이행적 함수 종속이란 A -> B가 와 B -> C가 존재하면 A -> C 가 성립하는데, 이때 C가 A에 대해 이행적 함수 종속이 되었다고 말한다.

### 보이스/코드 정규형
* 제 3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말한다.
  * 결정자 : X -> Y일 때, X는 결정자, Y는 종속자이다

## 트랜잭션
* 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
### 원자성
* 트랜잭션 안의 작업이 모두 수행되거나 되지 않았거나 보장되어야한다.
### 일관성
* 데이터베이스 안의 모든 데이터는 허용된 방식으로만 변경되어야한다
### 격리성
* 트랜잭션 수행 시 서로 끼어들지 못하는 것
### 무결성
* 데이터의 정확성, 일관성, 유효성을 유지하는 것
  * 개체 무결성, 참조 무결성, 고유 무결성, NULL 무결성

### 파티셔닝과 샤딩
* 테이블이 커질수록 성능이 감소할 것이다. 이를 위해 데이터베이스를 분리하는 방법이 파티셔닝과 샤딩이다.
* 파티셔닝 : 매우 큰 테이블을 여러개의 테이블로 분할하는 작업. MySQL에서 자체적으로 지원한다.
  * 수평 파티셔닝 : 테이블의 각 행을 다른 테이블에 분산시키는 것. 리스트 파티셔닝, 레인지 파티셔닝, 해쉬 파티셔닝 등이 있다.
  * 수직 파티셔닝 : 테이블의 일부 열을 빼내는 형태. 정규화도 수직 파티셔닝과 관련있는 과정이라고 볼 수 있다. 다만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정이다.
* 샤딩 : 동일한 스키마를 가진 여러대의 데이터베이스 서버들에 데이터를 작은 단위로 분산 저장하는 기법. 수평 파티셔닝의 일종이라 할 수 있다.

## 데이터베이스의 종류
### RDBMS(관계형 데이터 베이스)
* 행과 열을 가지는 표 형식의 데이터를 저장하며, 서로 관련된 데이터 지점에 대한 접근을 저장 및 제공하는 데이터베이스 유형
### NoSQL
* Not only SQL, SQL이 아닌 데이터베이스. MongoDB와 Redis가 대표적

## 인덱스
* 데이터베이스에서 데이터를 빠르게 찾을 수 있는 장치. 책의 찾아보기(인덱스)와 같다. 조회 속도를 크게 향상시킨다.
### 인덱스 사용시 주의점
* 인덱스는 비용이다. 인덱스를 사용시 삽입, 수정, 삭제시의 비용이 증가하므로 주의해야한다.
* DB크기의 10%정도의 추가 공간이 필요하다
* 인덱스 생성 자체에도 시간이 걸린다.

## 조인
* 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물로 만드는 것.
* inner join : 두 행이 모두 일치하는 부분만 표기
* left outer join : 왼쪽테이블의 모든 행이 결과 테이블에 표기
* right outer join : 오은쪽 테이블의 모든 행이 결과테이블에 표기
* full outer join : 두 개의 테이블을 기반으로 조인조건에 만족하지 않는 행까지 모두 표기

# 심화 질문

## Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
* 기본키 : 데이터를 구분하기 위한 키. 두 개 이상의 필드가 합쳐져서 기본키가 될 수도 있으며, 중복된 값이거나 null일수 없다. 인위적으로 만든 인조키와 자연적으로 있던 자연키가 있다.
* 후보키 : 기본키로 사용 할 수 있는 필드(의조합). 유일해야하고, null일수 없다.
* 슈퍼키 : 레코드를 고유하게 식별할 수 있는 하나 이상의 속성. 후보키를 포함하며, 유일성을 위해 필요하지 않는 필드가 포함 될 수 있다.
* 외래키 : 다른 테이블의 기본키를 참조하여 테이블간의 연관 관계를 설정하는 키.
* 유일키 : 테이블 내의 레코드를 유일하게 식별할 수 있는 속성. null값을 허용한다.
### 기본키는 수정이 가능한가요?
* 가능하지만, 수정을 하게 된다면 데이터 무결성에 영향을 줄 수도 있다.
### 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
* 가능한 후보키중에 하나를 클러스터형 인덱스로 지정한다. 만약 후보키가 없다면, InnoDB가 자체적으로 키를 생성하여 클러스터형 인덱스를 생성한다.
### 외래키 값은 NULL이 들어올 수 있나요?
* 가능하다.
### 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
* 데이터의 삽입과 수정시에는 UNIQUE 조건을 검사하기 위해 추가적인 시간이 소요된다. 또한 UNIQUE 인덱스 관리를 해야하기에 삽입, 수정, 삭제시에 시간이 소요된다. 하지만 검색시에는 UNIQUE 인덱스를 기반으로 더 빠르게 검색이 가능하다.

## RDB와 NoSQL의 차이에 대해 설명해 주세요.
* RDB : 데이터가 구조화되어있고, SQL을 사용한다. 데이터의 무결성이 있다.
* NoSQL : 다양한 데이터 저장 방식이 있다. 테이블간 관계를 정의하지 않고, 스키마 변경이 유연하여 빠르게 변화하는 요구사항에 적합하다. 또한 데이터 확장성이 높다.
### NoSQL의 강점과, 약점이 무엇인가요?
* 강점 : 확장성, 유연성, 대용량 데이터 처리
* 약점 : 데이터 무결성, 표준화되지 않은 쿼리 언어, 복잡한 쿼리 처리에 부적합함
### RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
* RDB는 데이터가 구조화되어있고, 데이터의 무결성을 엄격하게 지킨다. 이러한 과정에서 부하가 많이 걸릴 수 있고, 테이블이 많아지면 테이블간 Join을 많이 하게 되므로 속도가 느려질 수 있다.
### NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.
* Redis를 사용하였다. 키-밸류 기반으로 더 빠른 데이터 저장 및 조회가 가능하고, 인메모리 DB의 특성을 이용해 캐싱 및 메시지큐로 사용 가능했다.

## 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
* 트랜잭션 : 데이터베이스에서 하나의 논리적인 작업의 단위. 여러개의 연산이 포함 될 수 있다.
* ACID : 데이터 무결성을 위한 4가지 기본 속성
  * Atomicity(원자성) : 트랜잭션의 모든 연산은 전부 실행되거나, 그렇지 않아야한다.
  * Consistency(일관성) : 트랜잭션 실행 전 후로 데이터베이스가 일관된 상태를 유지해야한다.(트랜잭션은 데이터베이스가 허용하는 조건을 만족해야한다)
  * Isolation(독립성) : 독시에 여러 트랜잭션이 실행될 때, 각 트랜잭션은 다른 트랜잭션의 연산으로부터 독립적이어야 한다.
  * Durability(영속성) : 트랜잭션이 성공적으로 완료되면, 해당 결과는 영구적으로 데이터베이스에 남아야하며, 시스템 장애가 발생하더라도 유지되어야한다.
### ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
* checkpoint : 
* 트랜잭션 종료 후 커밋을 통해 해당 커밋의 로그를 저장한다.
### 지연 갱신 기법, 즉시 갱신 기법
* 
### 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
* 작업이 한번에 반영되야만 할 때. 여러 쓰기 작업이 동시에 이루어질 때, 중간에 작업을 멈추면 이전에 실행한 작업도 모두 취소해야한다면 트랜잭션을 사용 할 수 있다.
### 읽기에는 트랜잭션을 걸지 않아도 될까요?
* 읽기 작업은 데이터베이스를 변경하지 않는다. 그렇기에 많은 경우에 트랜잭션이 필요 없지만, 몇 몇 경우에 읽기작업에도 트랜잭션이 필요하다. 예를 들어 한 작업 안에서 동일한 데이터를 두 번 이상 읽어야하고, 그 데이터가 같아야 하는 경우에 필요하다. 또한 여러 개의 데이터를 읽을 때, 해당 데이터들이 동일한 시점의 데이터여야 하는 경우에도 트랜잭션이 필요하다.

## 트랜잭션 격리 레벨에 대해 설명해 주세요.
* Read Uncommitted : 아예 격리가 되지 않는 레벨
* Read Committed : 커밋된 데이터만 읽기 가능
* Repeatable Read : 선행 트랜잭션이 참조하는 모든 행에 대해 후행 트랜잭션이 갱신하거나 삭제 할 수 없다.
* Serializable : 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때 까지 후행 트랜잭션이 갱신하거나 삭제, 새로운 레코드를 삽입할 수 없다.
### 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
* 설계철학과 목표, 기술적 제약 등의 문제로 모두 구현하지 않은 경우도 있다. 예를 들어 MySQL은 모두 구현하고, 오라클은 Read Uncommited는 거의 필요가 없기 때문에 구현하지 않고 Repeatable Read는 Serializable이 효과적으로 구현되어 지원하지 않는다.
### innodb에서 READ COMMITTED에서 커밋된 데이터만 조회하는 방법
### REPEATABLE READ와 READ COMMITTED의 undo log 효용성
* undo log의 깊이가 다르다. reapeatable read는 undo log내에서 내 트랜잭션 로그 직전 번호를 읽는다. (MVCC melti version concorrncy control)
### 각 레벨에서 발생 할 수 있는 문제?
### 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
* Redo Log : DB 장애시 복구에 사용한다. 영속성을 위해 필요하다. Buffer Pool에 저장되어있던 데이터의 유실을 방지하기 위해 사용한다. 데이터 변경시 모든 것을 기록한다.(읽기 x)
* Undo Log : 트랜잭션이 롤백 되거나, 다른 트랜잭션이 이전의 데이터를 읽어야하는 작업을 수행 할 때 필요한 원래 데이터를 제공한다.
### 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
* 데이터베이스에서 CRUD의 기본적인 작업을 수행하는 소프트웨어 구성 요소. 데이터의 저장, 접근 방식을 결정한다.
### rollback과 recovery 개념 차이
* 트랜잭션 : 트랜잭션의 논리적인 오류에서의 되돌림
* recovery : 시스템이 물리적으로 잘못되었을 때 트랜잭션을 다시 실행
## 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
* 데이터베이스에서 특정 필드에 대해 빠른 검색이 필요할 때 사용하는 기술. 컬럼에 대해 정렬한 후 별도의 메모리 공간에 물리적 주소와 함께 저장한다.
### 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
* 데이터베이스 수정을 하는 경우, 인덱스도 그에 맞게 수정을 해야한다. 인덱스를 읽기만 하는 경우에 인덱스는 효과적이지만 그렇지 않은 경우에는 오히려 성능이 낮아질 수 있다.
### 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
* 인덱스에서 사용하지 않기로 한 값은 인덱스 유지 관리 정책에서 제외된다. 해당 값의 변경은 인덱스의 성능에 영향을 주지 않는다. 그렇기에 자주 수정되는 컬럼은 인덱스에서 제외하는것도 전략이 될 수 있다.
### ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
* ORDER BY : 인덱스가 없는 경우에는 모든 행을 스캔하여 주어진 열에 대해 정렬을 수행한다. 인덱스가 있고 ORDER BY 조건이 인덱스의 정렬조건과 같은 경우, 이미 정렬되어 있으므로 인덱스를 사용하여 그대로 결과를 반환한다. 
* GROUP BY : 인덱스가 없는 경우 모든 행을 스캔하고, 그룹화 할 컬럼의 고유 값을 찾는다. 그 후 집계합수를 적용한다. 인덱스가 있는 경우, GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 같은 경우 사용 할 수 있다.
### 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
* 기본키는 자동으로 클러스터형 인덱스가 생성된다. 클러스터형 인덱스는 테이블의 레코드를 물리적으로 정렬한다. 하지만 일반 인덱스는 정렬된 컬럼에 따라, 물리 주소를 따로 가지고 있다.
### 그렇다면 외래키는요?
* 외래키도 인덱스를 사용할 수 있다. 인덱스를 사용하는 경우 JOIN의 성능이 향상된다.
### 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
* 클러스터형 인덱스는 물리적 저장에 영향을 미친다. 그 외에는 그렇지 않다.
* 클러스터형 인덱스가 없는 경우 순서를 지정하지 않고 힙에 저장된다. 클러스터형 인덱스가 존재하는 경우 보통 해당 키에 따라 재정렬되며, 보통 기본키가 그 역할을 한다.
### 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
* 몽고DB는 인덱스를 가지고 있다. Hash, TTL index 등 다양한 인덱스를 제공한다. redis는 get작업은 이미 O(1)의 복잡도를 가지므로 인덱스로 필요치 않고, 보조키에서는 해시 인덱스를 구축 할 수 있다.
### (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
* 인덱스를 사용하지 못한다. 반대로 A조건만 사용하고 B조건을 사용하지 않는 경우에는 가능하다. MySQL 8.1이상에서는 A조건에 따라 모두 날리는 형식으로.. 대신 A가 데이터 내에서 적어야함

## RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.
* 레플리케이션 : 데이터를 여러 위치에 복제하여 저장하는 방식. 보조 서버에서 읽기를 처리하여 주 서버의 부하를 줄인다. master-slave 구조로 구성된다. 수직적인 구조로 구축한다. master가 다운된 경우 복구가 까다롭다.
* 클러스터링 : 여러 대의 DB서버가 수평적인 구조로 관리하는 방식. 여러 서버가 요청을 나눠 처리함으로써 성능을 향상시킨다. 노드들간의 데이터가 동기화된다. 1개 노드가 죽어도 다른 노드가 살아있어 시스템을 장애없이 운영할 수 있다.
### 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
* 2-Phase Commit (2PC) : 준비단계에서 모든 참여 노드가 트랜잭션을 커밋할 준비가 되어있는지 확인하고, 두 번째 단계에서 모든 노드가 준비되었다면 커밋을 진행한다.
* 3-Phase commit : 2PC에서 중간 단계에 사전 커밋단계를 거친다. 이를 통해 트랜잭션 상태를 보다 명확하게 파악할 수 있도록 한다.
* SAGA 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리한다. 중간에 실패가 발생한 경우, 보상 트랜잭션을 통해 일관성을 유지한다.
### 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
* 데이터 동기화가 완료되기 전까지 슬레이브에서의 읽기 요청을 제한하거나, 마스터로 리다이렉션하여 일관성을 유지 할 수 있다.
### 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
* 두개 이상의 트랜잭션이 특정 자원(데이터)를 점유 한 채 다른 트랜잭션이 점유한 자원(데이터)를 요구하면 데드락이 발생한다.
* 예방 : 각 트랜잭션이 실행되기 전 필요한 모든 자원을 락한다. 속도가 느려 질 수 있다.
* 회피 : 
  * Wait Die : 다른 트랜잭션이 점유한 자원을 요청 할 때, 자신이 먼저 들어왔다면 기다리고 그렇지 않다면 포기하고 나중에 다시 요청한다. 점유 대기 조건을 만족하지 않게한다.
  * Wound-Wait : 먼저 들어온 트랜잭션이면 데이터를 선점하고, 그렇지 않다면 대기한다. 비선점을 만족하지 않게 한다.
### 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
* 샤딩 : 테이블을 여러 서버에 분산시켜 저장하는 방식. 
* 하나의 데이터베이스가 너무 커지면 샤딩을 사용해서 분산을 할 수 있다. 거기에 안정성을 위해 샤딩한 각각의 DB서버에 레플리케이션을 적용할 수 있다.

## 정규화가 무엇인가요?
* 데이터베이스 수정, 삽입, 삭제 작업시의 이상현상을 방지하고 무결성과 일관성을 유지하기 위해 테이블을 분해해서 여러개의 테이블로 만드는 과정. 이상현상을 제거하고 무결성과 일관성이 있지만, JOIN연산으로 인한 응답 시간이 느려질 수 있다.
### 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
* 특정 속성에 해당하는 값이 없어 null을 입력해야 하는 삽입 이상
* 즉정 튜플 삭제시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 삭제 이상
* 튜플 생신시 중복된 데이터의 일부만 갱신되어 일어나는 갱신 이상
### 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
* 제 1정규형 : 모든 컬럼이 원자값을 가진다. 각 컬럼에는 하나의 값만 가지게 된다.
* 제 2정규형 : 부분 함수 종속성을 제거한다. 즉 모든 비주요 속성이 기본키 전체에 대해서만 종속된다.
* 제 3정규형 : 이행 함수 종속성을 제거한다. 비주요 속성간에 종속성이 사라진다.
* 보이스코드 정규형 : 모든 결정자가 후보키가 된다. 후보키가 아닌 속성에 의해 결정되는 종속성을 제거한다.
### 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
* 정규화를 하면 데이터의 무결성과 일관성이 강해진다. 하지만 테이블이 분해됨으로써 구조가 복잡해 질 수 있고, join연산으로 인해 성능이 느려질 수 있다. 어떤 데이터에서 테이블 구조의 변경이 없고, 데이터의 수정이나 삭제가 잘 일어나지 않는다면 역정규화를 한 테이블이 성능상 유리할 수 있다.

## View가 무엇이고, 언제 사용할 수 있나요?
* 하나 이상의 테이블 가져온 데이터의 가상 테이블이다. 데이터의 복잡성을 숨기고, 데이터의 보안을 강화하는 목적으로 사용된다. 사용자는 view를 하나의 테이블처럼 실행 할 수 있다.
* Materialized View(구체화된 뷰) : 정의된 쿼리를 미리 실행하여 물리적으로 데이터를 가지고 있으며, 그 데이터 내에서 결과 리턴
### 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?
* 바뀌기도 하고 그렇지 않은 경우도 있다. 원래 테이블의 기본키를 포함한 필드로만 구성해야만 삽입, 삭제, 수정이 가능하다.
### 동일한 쿼리를 view와 기존 데이터에서 실행할때, view가 더 빠른 경우도 있을까?
* 그렇지 않다. 하지만 Materialized View를 사용하는 경우, 복잡한 통계쿼리 등에서 속도가 향상 될 수도 있다.

## DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.
* 두 개 이상의 테이블에서 연관된 컬럼을 기준으로 연결하여, 관련 있는 하나의 결과로 결합하는 연산이다.
* inner join : 두 테이블 모두에서 일치하는 데이터만 반환한다.
* Left, Right : 한쪽의 모든 데이터와 다른 쪽의 일치하는 데이터를 반환한다. 다른 쪽에 일치하는 데이터가 없는 경우, null로 표시된다.
* Full join : 두 테이블의 모든 데이터를 반환한다. 일치하는 데이터가 없는 경우, null로 표시된다.
### 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
* 대표적으로 세 가지가 있다.
* Nested Loops Join : 가장 간단한 Join 방식으로, 한 테이블의 각 행을 다른 테이블의 모든 행과 비교하여 일치하는 행(완전탐색). 테이블이 작은 경우, 조인 조건에 맞는 데이터가 매우 적은 경우에 효율적이다. 또한 한쪽 입력이 적고, 나머지에 index가 설정되어 있는 경우 효율적이다.
* Hash Join : 한 테이블의 조인 컬럼을 기준으로(보통 작은 쪽) 해시 테이블을 생성하고, 다른 테이블을 순회하면서 해시 테이블을 참조하여 일치하는 행을 찾는다. 대용량에서 효율적이다.
* Merge Join : 두 테이블을 조인 컬럼을 기준으로 정렬 후에, 두 테이블의 행을 동시에 순회하며 일치하는 행을 찾아 결과에 추가한다. 테이블이 이미 조인 컬럼에 대해 정렬되어 있거나, 인덱스를 활용할 수 있어 정렬 비용이 낮을 때 사용된다. 또한 두 입력의 크기가 비슷할 때도 효율적이다.
* 이 때, 먼저 엑세스되어 주도하는 테이블이 Driving Table, 반대를 Driven Table이라 한다.
* Outer Join의 경우에는 Outer가 되는 테이블이 반드시 Driving Table이 된다. 이는 힌트를 통해서도 유도 할 수 있다. 
### 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
### 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
* Merge Join의 경우에는 정렬을 활용한다. 이 때, 인덱스가 조인 컬럼에 따라 정렬되어 있는 경우, 인덱스를 사용할 수 있기에 비용이 낮아져 Hash Join이 아닌 Merge Join을 사용 할 수 있게 된다.
### 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.
* 옵티마이저가 조인할 테이블의 순서와 조인 방법을 결정한다. 중간 단계에서 메모리에 적재되는 데이터의 양이나 처리 시간등을 예상해서 결정하게 된다.
* 순서, 조인방법에 따라 조인을 진행하게 된다. 중간 결과를 활용해서 모든 테이블이 조인 될 때 까지 반복한다.
* 인덱스의 정렬 순서가 조인 순서에도 큰 영향을 끼친다.
* 또한 Outer Join의 경우 먼저 읽어야 하기에, 최적화가 불가능하다. 그렇기에 Outer Join을 사용하는 경우 신중하게 순서를 정해야 할 것이다.

## B-Tree와 B+Tree에 대해 설명해 주세요.
* 확장된 균형 이진 탐색 트리이며 데이터베이스에서 자주 쓰이는 자료구조이다.
* B-Tree : 하나의 노드에 여러 정보를 가질 수 있고, m개의 자식을 가질 수 있고, 모든 리프 노드가 같은 레벨에 위치한다.
  * 중복된 자료를 가지지 않는다. 
  * root node는 자신이 leaf node가 되지 않는 이상 2개 이상의 자식을 가진다.
  * 노드 내 데이터는 정렬된 상태를 유지한다.
  * root node와 leaf node를 제외한 노드는 m//2 ~ m개의 자식을 가질 수 있다.
  * 노드의 키는 (m//2)-1 ~ m-1 개의 키가 포함 될 수 있다ㅏ.
  * 자식 수의 하한값을 t라고 하면, m = 2t-1을 만족한다.
* B+Tree : B-Tree의 단점인 구조를 유지하기 위해 새로운 노드가 생기거나 추가적인 연산이 많이 발생하는 점을 해결하기 위해 등장한 자료구조이다. 
  * leaf node에 모든 자료들이 존재하고, 연결리스트로 되어 있어 범위탐색에 유리하다.
  * 리프노드를 제외한 나머지 노드들은 리프 노드 접근에 대한 주소만을 포함한다. 그러므로 리프노드를 제외한 나머지 노드에 더 많은 값을 넣을 수 있다.
  * 중복된 키를 가지고 있다.
* B트리 계열은 작은 레벨 탐색으로도 많은 데이터를 다룰 수 있는 장점이 있다.
### 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
* B+Tree는 실제 데이터가 리프노드에서만 이루어져 범위탐색에 유리하고, 트리의 높이가 더 낮아지는 장점이 있다.
* 하지만 실제 데이터를 찾기 위해 무조건 리프 노드까지 내려가야만 하기에 데이터를 하나만 찾을 때에는 오히려 B-Tree가 더 빠를 수 있다. 또한 링크드리스트를 관리하는 추가적인 비용이 들어갈 수 있다.
### DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
* 한 노드에 여러개의 값을 저장함으로써 디스크 I/O작업을 최소화 할 수 있고, 트리의 높이를 비교적 더 낮게 유지할 수 있다. 또한 범위 검색에 있어 B트리 계열이 더 효율적이다.
### 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.
* BST의 특성상 읽는 방향에 따라 반대방향으로도 데이터를 읽어 올 수 있다. B+tree는 리프노드가 양방향 연결리스트로 되어 있기에, 역순의 정렬도 효과적으로 처리 할 수 있다.

## DB Locking에 대해 설명해 주세요.
* 데이터베이스에서 동시성 제어를 위해 사용되는 메커니즘. 데이터의 일관성과 무결성을 유지하기 위해 필요하다. 트랜잭션 충돌이 발생하는 것을 방지한다.
* shared lock : 데이터에 대해 읽기만 가능하게 한다. 여러 트랜잭션에서 동시에 shared lock을 가질 수 있다.
* exclusive lock : 하나의 트랜잭션에서 읽기와 수정을 모두 가능하게 한다. 다른 트랜잭션에서는 해당 데이터에 대해 어떤 접근 권한도 가지지 못한다.
* 개별 행에 대한 락(동시성 제어 up, 관리 비용 up), 페이지 단위 락, 테이블 단위(동시성 down, 관리비용 down) 락 등의 레벨이 있다.
### Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
* Pessimistic Lock(비관적) : 충돌 발생 가능성이 있다고 가정한 락. 데이터 엑세스 전에 락을 걸어 충돌을 예방한다.
* Optimistic Lock(낙관적) : 충돌 발생이 없을 것으로 가정하고, 실제 충돌이 감지되었을 때 대처하는 락. 변경이 감지되면 롤백하고 재시도한다. 
### 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
* 데이터베이스 자체적으로, 트랜잭션 실패나 중단시 락을 해제함으로써 해결 할 수 있다. 하지만 데드락 등 실행이 중단된 경우 이렇게 할 수 없으므로, 락에 대해 제한 시간을 걸어 이후레 락을 자동으로 해제하고, 진행중인 트랜잭션을 되돌리는 등의 조치를 취해두었다.
* 사용자레벨에서도 자체적으로 timeout 및 롤백을 걸고 재시도를 하는 로직을 통해 어느정도 해결 할 수 있다.

## 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?
* DB서버의 스케일 업, 스케일 아웃 등을 할 수 있다.
* 스케일 업을 할 경우에는 서비스가 중단되는 문제가 있다.
* 스케일 아웃을 할 경우에는 여러 DB서버를 잘 관리해야한다.
  * 샤딩 : 데이터베이스의 테이블을 여러 서버에 분산시킨다.
  * 클러스터링, 리플리케이션 등을 통해 데이터를 여러 서버에서 관리하여 읽기 작업 부하를 분산한다.
### DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?
* 복잡한 쿼리를 날리는 등 DB에 많은 부하를 주지 않고, 간단한 쿼리 여러번을 날려 후처리를 서버에서 함으로써 DB의 부하를 줄일 수도 있다.
* 혹은 테이블을 파티셔닝하여 쿼리 성능을 향상시킬 수도 있다.
* 잘 변하지 않고 자주 쓰이는 쿼리는 결과를 캐싱하여 사용할 수 있다.
## Schema가 무엇인가요?
* 데이터베이스의 구조 또는 설계이다. 엔티티(객체), 속성, 관계, 뷰, 인덱스 등이 포함될 수 있다.
### Schema의 3계층에 대해 설명해 주세요.
* 하나의 데이터베이스를 사용자의 관점에 따라 나눈 것. 
* 외부 스키마 : 외부에서 사용자가 보는 관점, 사용자 뷰라고도 한다. 사용자에 따라 다르게 출력 될 수 있으며, 여러 개가 존재한다.
* 개념 스키마 : 모든 응용 시스템과 사용자가 필요로 하는 데이터를 통합한, 전체의 데이터베이스 구조를 논리적으로 정의한 것. 일반적으로 이야기하는 스키마는 개념 스키마이다.
* 내부 스키마 : 데이터가 실제로 저장되는 방식, 컴퓨터 관점에서의 정의이다. 물리적 저장 방식, 경로, 인덱싱 방법, 클러스터링 방법 등을 포함한다.

## DB의 Connection Pool에 대해 설명해 주세요.
* 커넥션 풀은 데이터베이스와의 연결을 여러 개 미리 생성해두고, 해당 연결을 재사용하는 기술. 데이터베이스에 접근하는 애플리케이션의 성능을 향상시키고, 자원 사용을 최적화하기 위해 사용됩니다.
* 커넥션 풀 사용을 통해, 서버와의 거리가 멀 때의 지연시간을 줄일 수 있다.
* 동시 요청 성능을 향상할 수 있다.
* 커넥션 객체의 생성과 해제 과정에서의 자원 낭비를 줄일 수 있다.
### DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.
* 클라이언트가 db와 통신하기 위한 드라이버를 로드하고, 연결 정보를 설정한다.(DB 서버 주소, 포트번호, DB명, 사용자 이름 및 비밀번호 등) 이후 TCP 요청을 통해 연결되고, 로그인 정보를 통해 접근권한이 결정된다. 이후 쿼리를 교환하고, 연결을 종료한다.
### DB와 클라이언트간의 통신에는 어떤 통신이 주로 사용되나요?
* TCP?
## Table Full Scan, Index Range Scan에 대해 설명해 주세요.
* Table Full Scan : 테이블의 모든 행을 처음부터 끝까지 순차적으로 검색하는 방법. 쿼리가 데이터의 대부분을 반환해야 하거나, 사용 가능한 인덱스가 없을 때 사용한다.
* Index Range Scan : 쿼리 조건이 인덱스 사용이 가능 할 때 사용한다.
### 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
* 테이블의 데이터를 대부분 반환하는 경우, 테이블 풀 스캔 방식이 오히려 더 효과적일 수 있다. 인덱스를 타는 과정을 거치지 않기 때문이다.
* 낮은 카디널리티를 가지는 등 인덱스가 효과적이지 않은 경우에도 풀스캔이 될 수 있다.
### COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?
* Count(*), Count(1): null에 상관없이 전체 행 수를 센다.
* Count(column) : 해당 칼럼이 인덱스 사용 가능한 경우, 이를 통해 성능이 향상된다. 아닌 경우 풀스캔을 하기에 실행 시간이 더 늘어날 수 있다.

## SQL Injection에 대해 설명해 주세요.
* 공격자가 애플리케이션의 데이터베이서에 대해 직접 SQL쿼리를 주입하여 실행시키는 공격 기법. 이를 통해 DB에 무단으로 조회, 수정, 삭제 등이 가능하다.
* AND조건이나 OR조건을 활용해 조건문을 참으로 만드는 방법 등을 사용한다.
* ORM 라이브러리 사용, DB계정 권한 제어, 사용자 입력값에 대한 검증 등을 통해 해결 할 수 있다.
### 그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?
* Prepared Statements: SQL쿼리에서 코드와 데이터를 분리하는 방법. 
* ORM : 쿼리를 직접 입력하지 않고, 객체 지향적으로 DB를 추상화