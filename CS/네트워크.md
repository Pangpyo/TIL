# 네트워크
## TCP와 UDP
* OSI 4계층에서 사용하는 통신 프로토콜
### TCP
* 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부 확인
* 연결형
* 3 way handshake(연결)
  1. SYN단계 : 클라이언트의 ISN을 담아 SYN을 보냄
  2. SYN+ACK 단계 : 서버는 클라이언트의 SYN 수신 후 서버의 ISN과 클라이언트의 ISN+1을 담아 SYN을 보냄
  3. ACK 단계 : 클라이언트는 서버의 ISN+1 값인 승인번호를 담아 ACK를 보냄
* 4 way handshake(연결 해제)
  1. 클라이언트가 FIN을 보내고 서버의 응답을 기다림
  2. 서버는 ACK를 보냄
  3. 일정 시간 후 서버는 FIN을 클라이언트에 보냄
  4. 클라이언트는 서버로 ACK를 보내고 연결해제
### UDP
* 신뢰성이 보장되지 않기에 데이터 손실 가능성이 있음
* 신뢰성 확인을 하지 않기에 TCP에 비해 용량이 가볍고 송신 속도가 빠름
* 비 연결형
## HTTP
* HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. 하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다. HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.
### 특징
* 요청과 응답 두 가지 유형이 있음
* 헤더와 바디로 이루어짐
* 무상태성
  * 클라이언트와 서버 간에 상태 정보를 들고있지 않음
* 비연결성
  * 한번 통신 후 연결이 끊어짐
### HTTPS
* 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
* SSL handshake
  1. Client Hello 
    * 브라우저가 사용하는 암호화 정보와 알고리즘을 보냄
  2. Server Hello
    * 사용 가능한 알고리즘 선택, SSL인증서 클라이언트로 전달
  3. 서버 인증서 확인
  4. Premeter Secret
    * 대칭키 생성 후 서버로 전송
  5. Premeter Secret 복호화
  6. SSL handshake 종료 및 HTTPS 통신 시작

### HTTP 응답코드
* 1xx : 정보 응답
  * 100 Continue : 지금까지의 상태가 괜찮음
  * 101 Swiching Protocol : 클라이언트가 보낸 요청 헤더에 대한 응답에 들어가며 서버에서 프로토콜을 업데이트 할 때
  * 102 Processing : 처리중일 때
* 2xx : 성공
  * 200 OK : 성공적으로 처리
  * 201 Created : 새로운 리소스가 생성됨
  * 202 Accepted : 요청은 허용되었지만, 처리가 완료되지 않음
  * 204 No Content : 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없음
* 3xx : 리다이렉션
  * 300 Multiple Choices : 선택 항목이 여러개이다
  * 301 MovedPermanetly : 지정한 리소스가 새로운 URI로 이동하였다
  * 302 Found : 다른 위치 찾음
  * 303 See Other : 다른 위치 보기
  * 307 Temporary Rediect : 임시로 리다이렉션 요청이 필요하다
* 4xx : 클라이언트 에러
  * 400 Bad Request : 요청이 잘못되었다
  * 401 Unauthorized : 리소스에 대한 권한이 없음
  * 403 Fobidden : 지정한 리소스에 대한 요청이 금지되었다
  * 404 Not Fount : 지정한 리소스를 찾을 수 없다
* 5xx : 서버 에러
  * 500 Internal Server Error : 서버에 에러가 발생하였다
  * 501 Not Implemented : 해당 URI의 메서드에 서버에서 구현되지 않음
  * 502 Bad Gateway : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다
* 사용자가 임의로 http 응답코드를 만들어서 사용하는 경우, 서버와 클라이언트 양 측에서 해당 코드에 대한 정보가 있어야한다. 그렇지 않으면 클라이언트에서는 xx0코드로 처리된다.

### HTTP 메소드
* 주요 메소드
  * GET : 리소스 조회
  * POST : 요청 데이터 처리, 주로 등록에 사용
  * PUT : 리소스를 대체, 해당 리소스가 없다면 생성
  * PATCH : 리소스 부분 변경
  * DELETE : 리소스 삭제
* 기타 메소드 
  * HEAD : GET과 동일하지만 메시지부분을 제외하고 상태줄과 헤더만 반환
  * OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
  * CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
  * TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행
* HTTP 메서드의 멱등성
  * HTTP 메서드중 GET, PUT, DELETE 등은 여러번 수행되어도 결과가 같은 멱등성을 가진다

### Rest란?
* Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것
* 이러한 규칙을 지켜 만든 API를 Restful API라고 한다.
* HTTP URI를 통해 자원을 명시하고, Method를 통해 해당 자원에 대한 동작을 적용한다.
* 장점
  * 쉬운 사용성 : API의 의도를 쉽게 파악 가능
  * 클라이언트와 서버의 분리
  * 데이터의 명확한 표현
* 단점 
  * 메서드 형태가 제한적
  * 표준이 명확하지 않음

## 프록시 서버란?
* 클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 중간에 대신 전달해주는 서버
### 프록시서버 사용 이유
* 보안 : 서버의 IP를 숨기는 것이 가능
* 캐시 : 이전에 했던 요청들을 프록시서버에 캐싱해둘수 있다
### 포워드 프록시
* 클라이언트에서 요청을 할 때 직접 요청하는 것이 아닌 프록시서버를 거치는 방식이 포워드 프록시
* 캐싱, 보안을 위해 사용
### 리버스 프록시
* 서버에서 클라이언트에 직접 데이터를 전달하지 않고 프록시서버를 거치는 방식이 리버스 프록시
* 캐싱, 보안, 로드밸런싱
* nginx를 사용해 리버스 프록시 서버 사용 가능

### DNS서버란?
* 도메인 네임 시스템은 호스트의 도메인 네임을 네트워크 주소로 변환하거나, 그 반대의 역할을 수행하는 시스템이다.
* Local DNS(기지국 DNS) 서버란?
  * 인터넷을 사용하기 위해서는 IP를 할당해주는 통신사에 등록해야한다. 이후 컴퓨터가 LAN선을 통해 연결되면, 가입했던 통신사의 기지국 DNS서버가 등록되게 된다. 


## naver.com을 치면 일어나는 일
### 네트워크 흐름 측면에서
1. 사용자가 브라우저에 도메인 네임 `www.naver.com` 을 입력한다.
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3. 페이지 URL 정보와 전달 받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
4. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력 되어 사용자가 볼 수 있게 된다.

### DNS서버 에서
1. 브라우저가 캐시에서 `www.naver.com`에 대응되는 IP주소가 존재하는지 확인한다
  * 브라우저 자신이 저장하고 있는 캐시를 가장 먼저 탐색한다
  * 이후 os에 저장된 캐시를 탐색한다. (윈도우의 host 파일)
  * 라우터(공유기)에 저장되어 있는 캐시 정보를 탐색한다
  * local DNS서버의 캐시를 확인한다
2. local DNS서버에서 `www.naver.com`에 대응되는 IP주소 정보를 요청한다
3. Root DNS 서버는 .com으로 끝나는 도메인에 대한 DNS정보가 담긴 서버의 IP주소를 반환
4. 반환받은 주소를 통해 .com DNS서버로 다시 `www.naver.com`에 대한 IP주소 정보 요청
5. .com DNS서버는 `naver.com` 도메인에 대한 정보가 담긴 서버의 IP 주소 반환
6. `naver.com` DNS서버는 `www.naver.com` IP주소가 저장되어있어 해당 IP주소를 반환한다

# 네트워크 심화질문
## 쿠키와 세션의 차이에 대해 설명해주세요.
* 쿠키와 세션 :  HTTP는 상태를 저장하지 않기때문에, 상태를 저장하기 위해 사용한다.
* 쿠키 : 클라이언트에 키와 값으로 저장된다.
* 세션 : 쿠키를 기반으로 하지만, 쿠키로는 세션ID만을 저장하고 필요한 데이터는 서버에 저장한다. 서버 부하가 심하지만, 쿠키에 비해 보안이 강력하다.
### 세션방식의 로그인 방식에 대해 설명해주세요.
* 클라이언트에서 인증(로그인)이 이루어 졌을 때, 서버에서는 쿠키에 세션ID를 담아 클라이언트측에 보내면 로그인이 완료된다.
* 로그인 이후 해당 세션ID를 가지고 서버에 인가 요청을 한다. 그러면 사용자에 따른 응답을 한다.
### HTTP의 특성인 Stateless에 대해 설명해주세요.
* 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. 그렇기에 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
* 세션은 어느정도 stateless 원칙을 위반하는 측면이 있다. 하지만 매번 모든 정보를 클라이언트에서 함께 요청하다보면, 더 많은 데이터가 소모된다. 그렇기에 꼭 필요한 경우에는 어느정도 상태 유지를 사용해야만 한다.
### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
* 서버 모두가 세션을 공유해야 하기 떄문에 세션 저장소를 두어 모든 서버에서 해당 저장소를 바라보게 하면된다. 오류를 대비해 백업용 세션 저장소까지 준비하면 좋다.