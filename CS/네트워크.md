# 네트워크
## TCP와 UDP
* OSI 4계층에서 사용하는 통신 프로토콜
### TCP
* 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부 확인
* 연결형
* 3 way handshake(연결)
  1. SYN단계 : 클라이언트의 ISN을 담아 SYN을 보냄
  2. SYN+ACK 단계 : 서버는 클라이언트의 SYN 수신 후 서버의 ISN과 클라이언트의 ISN+1을 담아 SYN을 보냄
  3. ACK 단계 : 클라이언트는 서버의 ISN+1 값인 승인번호를 담아 ACK를 보냄
* 4 way handshake(연결 해제)
  1. 클라이언트가 FIN을 보내고 서버의 응답을 기다림
  2. 서버는 ACK를 보냄
  3. 일정 시간 후 서버는 FIN을 클라이언트에 보냄
  4. 클라이언트는 서버로 ACK를 보내고 연결해제
### UDP
* 신뢰성이 보장되지 않기에 데이터 손실 가능성이 있음
* 신뢰성 확인을 하지 않기에 TCP에 비해 용량이 가볍고 송신 속도가 빠름
* 비 연결형
## HTTP
* HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. 하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다. HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.
### 특징
* 요청과 응답 두 가지 유형이 있음
* 헤더와 바디로 이루어짐
* 무상태성
  * 클라이언트와 서버 간에 상태 정보를 들고있지 않음
* 비연결성
  * 한번 통신 후 연결이 끊어짐
### HTTPS
* 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
* SSL handshake
  1. Client Hello 
    * 브라우저가 사용하는 암호화 정보와 알고리즘을 보냄
  2. Server Hello
    * 사용 가능한 알고리즘 선택, SSL인증서(공개키와 서버의 신원정보를 포함) 클라이언트로 전달
  3. 서버 인증서 확인
  4. Premeter Secret
    * 대칭키 생성 후 서버로 전송
  5. Premeter Secret 복호화
  6. SSL handshake 종료 및 HTTPS 통신 시작

### HTTP 응답코드
* 1xx : 정보 응답
  * 100 Continue : 지금까지의 상태가 괜찮음
  * 101 Swiching Protocol : 클라이언트가 보낸 요청 헤더에 대한 응답에 들어가며 서버에서 프로토콜을 업데이트 할 때
  * 102 Processing : 처리중일 때
* 2xx : 성공
  * 200 OK : 성공적으로 처리
  * 201 Created : 새로운 리소스가 생성됨
  * 202 Accepted : 요청은 허용되었지만, 처리가 완료되지 않음
  * 204 No Content : 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없음
* 3xx : 리다이렉션
  * 300 Multiple Choices : 선택 항목이 여러개이다
  * 301 MovedPermanetly : 지정한 리소스가 새로운 URI로 이동하였다
  * 302 Found : 다른 위치 찾음
  * 303 See Other : 다른 위치 보기
  * 307 Temporary Rediect : 임시로 리다이렉션 요청이 필요하다
* 4xx : 클라이언트 에러
  * 400 Bad Request : 요청이 잘못되었다
  * 401 Unauthorized : 리소스에 대한 권한이 없음
  * 403 Fobidden : 지정한 리소스에 대한 요청이 금지되었다
  * 404 Not Fount : 지정한 리소스를 찾을 수 없다
* 5xx : 서버 에러
  * 500 Internal Server Error : 서버에 에러가 발생하였다
  * 501 Not Implemented : 해당 URI의 메서드에 서버에서 구현되지 않음
  * 502 Bad Gateway : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다
* 사용자가 임의로 http 응답코드를 만들어서 사용하는 경우, 서버와 클라이언트 양 측에서 해당 코드에 대한 정보가 있어야한다. 그렇지 않으면 클라이언트에서는 xx0코드로 처리된다.

### HTTP 메소드
* 주요 메소드
  * GET : 리소스 조회
  * POST : 요청 데이터 처리, 주로 등록에 사용
  * PUT : 리소스를 대체, 해당 리소스가 없다면 생성
  * PATCH : 리소스 부분 변경
  * DELETE : 리소스 삭제
* 기타 메소드 
  * HEAD : GET과 동일하지만 메시지부분을 제외하고 상태줄과 헤더만 반환
  * OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
  * CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
  * TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행
* HTTP 메서드의 멱등성
  * HTTP 메서드중 GET, PUT, DELETE 등은 여러번 수행되어도 결과가 같은 멱등성을 가진다

### Rest란?
* Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것
* 이러한 규칙을 지켜 만든 API를 Restful API라고 한다.
* HTTP URI를 통해 자원을 명시하고, Method를 통해 해당 자원에 대한 동작을 적용한다.
* 장점
  * 쉬운 사용성 : API의 의도를 쉽게 파악 가능
  * 클라이언트와 서버의 분리
  * 데이터의 명확한 표현
* 단점 
  * 메서드 형태가 제한적
  * 표준이 명확하지 않음

## 프록시 서버란?
* 클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 중간에 대신 전달해주는 서버
### 프록시서버 사용 이유
* 보안 : 서버의 IP를 숨기는 것이 가능
* 캐시 : 이전에 했던 요청들을 프록시서버에 캐싱해둘수 있다
### 포워드 프록시
* 클라이언트에서 요청을 할 때 직접 요청하는 것이 아닌 프록시서버를 거치는 방식이 포워드 프록시
* 캐싱, 보안을 위해 사용
### 리버스 프록시
* 서버에서 클라이언트에 직접 데이터를 전달하지 않고 프록시서버를 거치는 방식이 리버스 프록시
* 캐싱, 보안, 로드밸런싱
* nginx를 사용해 리버스 프록시 서버 사용 가능

### DNS서버란?
* 도메인 네임 시스템은 호스트의 도메인 네임을 네트워크 주소로 변환하거나, 그 반대의 역할을 수행하는 시스템이다.
* Local DNS(기지국 DNS) 서버란?
  * 인터넷을 사용하기 위해서는 IP를 할당해주는 통신사에 등록해야한다. 이후 컴퓨터가 LAN선을 통해 연결되면, 가입했던 통신사의 기지국 DNS서버가 등록되게 된다. 

# 네트워크 심화질문

## naver.com을 치면 일어나는 일
### 네트워크 흐름 측면에서
1. 사용자가 브라우저에 도메인 네임 `www.naver.com` 을 입력한다.
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3. 페이지 URL 정보와 전달 받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이 과정에서 소켓과 포트가 사용되며, 소켓은 IP주소와 포트번호, 사용할 프로토콜(TCP)의 조합으로 네트워크 서비스를 사용하는데 필요한 엔드포인트이다. HTTP는 80, HTTPS는 443포트로 연결 요청을 보낸다.
4. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력 되어 사용자가 볼 수 있게 된다.

### DNS서버 에서
1. 브라우저가 캐시에서 `www.naver.com`에 대응되는 IP주소가 존재하는지 확인한다
  * 브라우저 자신이 저장하고 있는 캐시를 가장 먼저 탐색한다
  * 이후 os에 저장된 캐시를 탐색한다. (윈도우의 host 파일)
  * 라우터(공유기)에 저장되어 있는 캐시 정보를 탐색한다
  * local DNS서버의 캐시를 확인한다
2. local DNS서버에서 `www.naver.com`에 대응되는 IP주소 정보를 요청한다
3. Root DNS 서버는 .com으로 끝나는 도메인에 대한 DNS정보가 담긴 서버의 IP주소를 반환
4. 반환받은 주소를 통해 .com DNS서버로 다시 `www.naver.com`에 대한 IP주소 정보 요청
5. .com DNS서버는 `naver.com` 도메인에 대한 정보가 담긴 서버의 IP 주소 반환
6. `naver.com` DNS서버는 `www.naver.com` IP주소가 저장되어있어 해당 IP주소를 반환한다.
7. 이 때 DNS서버의 쿼리는 naver.com의 웹 서버를 가리키고 있다.

### Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
* WS : 정적 컨텐츠(HTML 페이지)를 처리하고 사용자에게 전송한다. 대표적으로 Apache, nginx 등이 있다.
* WAS : 동적 컨텐츠를 처리하며, 사용자의 요청에 따라 서버 측에서 프로그램을 실행하여 결과를 생성한다. Tomcat 등이 있다.
* 둘을 나눔으로써 각각의 서버가 최적화된 작업을 처리 할 수 있다. WAS가 모든 일을 처리한다면, 시스템에 부담이 가중되어 응답 속도가 느려질 수 있고, 보안 취약점이 생길 수 있다.
### URL, URI, URN은 어떤 차이가 있나요?
* URI : 가장 넓은 개념으로, 인터넷의 자원을 식별하는데 사용되는 문자열.
* URL : 자원이 위치한 곳을 나타내며, 프로토콜을 포함하여 정확한 위치를 나타낸다.
* URN : 위치에 상관 없이 식별 가능한 고유한 이름. 위치가 변하더라도 자원을 이름으로 식별할 수 있다.
## 쿠키와 세션의 차이에 대해 설명해주세요.
* 쿠키와 세션 :  HTTP는 상태를 저장하지 않기때문에, 상태를 저장하기 위해 사용한다.
* 쿠키 : 클라이언트에 키와 값으로 저장된다.
* 세션 : 쿠키를 기반으로 하지만, 쿠키로는 세션ID만을 저장하고 필요한 데이터는 서버에 저장한다. 서버 부하가 심하지만, 쿠키에 비해 보안이 강력하다.
### 세션방식의 로그인 방식에 대해 설명해주세요.
* 클라이언트에서 인증(로그인)이 이루어 졌을 때, 서버에서는 쿠키에 세션ID를 담아 클라이언트측에 보내면 로그인이 완료된다.
* 로그인 이후 해당 세션ID를 가지고 서버에 인가 요청을 한다. 그러면 사용자에 따른 응답을 한다.
### HTTP의 특성인 Stateless에 대해 설명해주세요.
* 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. 그렇기에 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
* 세션은 어느정도 stateless 원칙을 위반하는 측면이 있다. 하지만 매번 모든 정보를 클라이언트에서 함께 요청하다보면, 더 많은 데이터가 소모된다. 그렇기에 꼭 필요한 경우에는 어느정도 상태 유지를 사용해야만 한다.
### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
* 서버 모두가 세션을 공유해야 하기 떄문에 세션 저장소를 두어 모든 서버에서 해당 저장소를 바라보게 하면된다. 오류를 대비해 백업용 세션 저장소까지 준비하면 좋다.

## HTTP 메서드에 대해 설명해주세요
* HTTP는 여러 가지 메서드를 정의하여 클라이언트가 서버에게 요청을 보내고 서버가 해당 요청에 응답하는 방식을 결정.
* GET : 리소스를 가져오기 위해 사용.
* POST : 새로운 데이터를 제출하기 위해 사용.
* PUT : 지정된 위치에 리소스를 저장하거나 업데이트하기 위해 사용.
* DELETE : 지정된 리소스를 삭제하기 위해 사용.
* PATCH : 리소스의 부분적인 업데이트를 위해 사용
* HEAD : GET과 유사하지만 헤더만을 반환.
* OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
### HTTP Method의 멱등성에 대해 설명해 주세요.
* 몇 HTTP 메서드들은 여러번 실행되어도 같은 결과를 가진다. 이를 멱등성이라고 한다.
### GET과 POST의 차이는 무엇인가요?
* 용도로 따지면 GET은 리소스를 조회할 때, POST는 새로운 데이터를 제출할 때 사용한다. 또한 GET은 데이터를 URL의 쿼리 문자열에 포함하여 서버로 전송하며, POST는 본문에 포함하여 전송한다. 또한 GET요청은 캐싱을 통해 성능 향상을 노려볼 수 있으며, POST는 일반적으로 캐싱하는것이 의미가 없다.
### POST와 PUT, PATCH의 차이는 무엇인가요?
* 용도로는 생성과 수정이라는 차이를 가진다. 실제 동작에서는, POST는 특정 자원을 목적으로 하는 것이 아니므로, 새로운 데이터가 생성되며 멱등성을 가지지 않는다. 하지만 PUT과 PATCH는 특정 자원을 상대로 하므로, 만약 이전에 없던 데이터에 대해 PUT이나 PATCH 메서드를 사용하더라도 멱등성을 가진다.
### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
* 일반적으로 GET요청은 캐싱을 할 수 있다. 하지만 GET에 Body가 포함되면 캐싱이 어려워지거나 일관성이 깨질 수 있다. 몇몇 서버나 미들웨어는 Get요청의 Body를 처리하지 못할 수도 있으며, 또한 Restful 설계원칙에 맞지 않게 된다.

## HTTP에 대해 설명해주세요.
* Hyper Text Transfer Protocol로, 서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규약.
* HTML, TEXT, IMAGE, 음성, 영상, JSON등의 데이터를 전송할 수 있다.
* 클라이언트가 요청하면 서버가 응답한다. 
* 무상태성(stateless) : 클라이언트와 서버 사이에 상태를 유지하지 않는다.
* 비연결성(connectionless) : 클라이언트와 서버 사이에 연결을 지속하지 않는다.

### 공개키와 대칭키에 대해 설명해 주세요.
* 대칭키 : 키가 동일한 암호화 방식. 해당 키를 알아야만 문서를 복호화해 볼 수 있게된다. 수행시간이 짧지만, 안전한 키교환 방식이 요구된다.
* 공개키 : 대칭키의 키교환 문제를 해결하기 위해 등장한것이 공개키이다. 공개키로 암호화, 개인키로 복호화한다. 속도가 느린 단점이 있다.
### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
* 서버의 인증서를 통해 서버의 신원을 확인할 수 있고, 공개키를 통해 안전하게 대칭키를 공유할 수 있다.
### SSL과 TLS의 차이는 무엇인가요?
* 둘 모두 보안을 위한 프로토콜.
* SSL은 사실상 종료되었으며, TLS는 SSL에서 보다 더 안전한 암호화 알고리즘을 사용한다. (RC4 > AES) 또한 더욱 엄격한 인증서 검증 과정을 거친다.

## 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
* 소켓 통신 : TCP/IP 프로토콜을 이용하여 데이터를 송수신하는 연결부를 의미한다.
* 웹소켓 : HTTP 레이어에서 작동하며, 실시간 양방향 통신을 가능하게 한다.
### 소켓과 포트의 차이가 무엇인가요?
* 소켓 : 네트워크에서 두 대의 디바이스간의 데이터 송수신을 위한 통신 엔드포인트. 소켓을 열기 위해서는 호스트에 할당된 IP 주소, 포트넘버, 프로토콜이 필요하다.
* 포트 : 네트워크에서 특정 소프트웨어의 데이터를 전달하기 위한 통신 채널을 식별하는 번호. 호스트 내부적으로 프로세스가 할당받는 고유한 값이다.
### 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
* 하나의 프로세스는 같은 IP주소, 같은 프로토콜, 같은 포트넘버를 가지는 여러개의 소켓을 가질 수 있다.
  * ex : 하나의 서버가 여러개의 클라이언트와 통신하는 경우 
### 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
* 웹 서버는 일반적으로 동시에 열 수 있는 소켓의 수를 제한하고, 요청을 처리한 후에는 소켓을 종료하기에 무수히 많은 소켓이 생성되지는 않는다. 다만 서버의 성능이 무한하다면 소켓수에 대한 제한을 두지 않고 무수히 많은 사용자의 요청을 동시에 처리할 수 있을 것이다.

## HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
* HTTP/1.1
  * 연결 한 개당 하나의 요청을 처리하도록 설계됨.
    * 요청과 응답이 순차적으로 이루어짐. 동시에 리소스를 주고 받는것이 불가능, 다수의 리소스를 처리하려면 대기시간이 길어짐
  * HOL(Head Of Line) Blocking이 발생할 수 있다.
    * 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * RTT(Rount Trip Time) : 매번 요청별로 연결을 만들게 되고, 3-way handshake가 반복적으로 일어나며 불필요한 RTT의 증가와 네트워크 지연을 초래
  * 무거운 Header 구조 : 매 요청마다 중복된 헤더 값을 전송하며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송
* HTTP/2
  * Multiplexed Streams : 연결 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며 응답은 순서에 상관 없이 스트림으로 받는다.
  * Stream Prioritization : 리소스간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결 할 수 있다.
  * Server Push : 클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다.
  * Header Compression : 헤더의 중복이 발생할 경우 Static/Dynamic Header Talbe 개념을 이용해 중복을 검출하고, 중복되지 않은 index값 + Header 정보를 허프만 인코딩 방식으로 데이터를 전송한다.
### HOL Blocking 에 대해 설명해 주세요.
* 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * HTTP/1.1에서는 연결 한개당 하나의 요청만을 처리하기 때문에 발생
  * HTTP/2에서는 패킷이 손실되어 재전송되는 동안, 뒤에 오는 패킷들은 대기상태가 되어 발생(순서를 보장해야하기 때문에)
### HTTP/3.0의 주요 특징에 대해 설명해 주세요.
* 반복된 Handshake 과정에서 발생하는 지연시간과 재전송으로 인한 HOL Blocking을 해결하기 위해 TCP 프로토콜 대신 QUIC 프로토콜을 사용한다.
 * TCP의 구조적 한계
  * TCP는 신뢰성을 위해 패킷을 순서대로 처리해야함, 이로 인해 패킷이 중간에 유실되거나 수신측의 패킷 파싱 속도가 느리다면 병목이 발생한다
  * UDP는 패킷의 목적지만 정해진다면 중간 경로를 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요 없음.
* QUIC 프로토콜 : Quick UDP Internet Conntections, 즉 UDP기반의 프로토콜
  * 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서대로 재조립할 수 있게 한다.
  * 또한 checksum을 사용해 패킷의 무결성을 보장한다.

## TCP와 UDP의 차이에 대해 설명해 주세요.
* TCP : 연결형 서비스, 흐름제어와 혼잡제어를 세종하며 패킷 손실 방지. 데이터의 순서와 신뢰성을 보장
* UDP : 비연결형 서비스, 데이터의 순서와 신뢰성을 보장하지 않음. 헤더의 크기가 작아 처리가 빠르고, 실시간 서비스에 적합하다. DNS조회, 스트리밍 등에 주로 사용된다.
### Checksum이 무엇인가요?
* Checksum : 송신된 자료의 무결성을 보호하는 방법.
### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
* 둘 다 체크섬을 수행 할 수 있지만, TCP는 필수이고 UDP는 선택적이다.
### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
* 데이터의 무결성을 확인 할 수 있지만, 오류를 정정할수는 없다.
### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
* 각 데이터 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서로 재조립할 수 있게 하며, 체크섬을 사용하여 오류가 있는지 확인하고 일치하지 않으면 재전송을 요청한다.
### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
* AIMD : 각 연결마다 윈도우 크기를 설정한다. 성공적으로 수신하면 1 증가시키고, 실패하면 절반으로 감소한다.
* Slow Start : 윈도우 사이즈를 2배씩 증가시키고, 혼잡현상이 한번 발생하면 1씩 증가시킨다.
### 왜 HTTP는 TCP를 사용하나요?
* TCP의 신뢰성의 때문에. 
### 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
* HOL 블로킹을 해결하기 위해 UDP를 사용한다. 패킷이 순서대로 도착해야함에 의한 시간 소요와 연결, 연결 해제를 위한 시간 소요를 줄이기 위해 사용한다. UDP에서 QUIC프로토콜을 사용함으로써 신뢰성을 확보한다.
### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
* Alt-Svc 헤더 응답이 있어야한다
### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
* QUIC 프로토콜을 사용하기 위해서는 클라이언트에서 더 많은 처리를 필요로 하므로 필요 하드웨어 사양이 높아지게 된다. 그렇기에 하드웨어 사양과 요구 속도, 신뢰성 여부 등을 파악해 선택하겠다.

## OSI 7계층에 대해 설명해 주세요.
1. 물리계층 : 데이터 전송 매체를 통해 신호를 전기적 신호로 변환하고 비트 스트림을 전송한다.
  * 케이블, 리피터, 허브
2. 데이터 링크 계층 : 물리적 네트워크를 통해 프레임을 전송하고 오류검출 및 재전송을 담당합니다. 맥 주소를 가지고 통신을 한다.
  * 브릿지와 스위치
3. 네트워크 계층 : 경로를 선택하고 경로에 따라 패킷을 전달한다. 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)을 담당한다. IP주소를 사용한다.
  * 라우터
4. 전송 계층 : 통신을 활성화하기 위한 계층. TCP와 UDP프로토콜이 대표적이다.
  * TCP, UDP
5. 세션 계층 : 데이터가 통신하기 위한 논리적인 연결. 애플리케이션간의 세션을 관리하고 데이터 교환 동기화를 담당한다.
6. 표현 계층 : 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다. 데이터의 인코딩과 암호화 등의 동작이 이루어짐
  * SSL/TLS 암호화
7. 응용 계층 : 최종 목적지로서 응용 프로세스와 직접 관계하여 일반적인 응용 서비스 수행.
  * HTTP
### Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
* 전송계층은 프로세스 간에 논리적인 통신을 제공한다면, 네트워크 계층은 호스트간의 논리적인 통신을 제공한다.
### L3 Switch와 Router의 차이에 대해 설명해 주세요.
* 거의 동일한 의미로 사용할 수 있다.
### 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
* 물리계층은 비트, 데이터 링크 계층은 프레임, 네트워크 계층은 패킷, 전송 계층은 세그먼트, 세션은 데이터, 표현, 응용 계층은 메시지라고 한다.
### ARP에 대해 설명해 주세요.
* IP주소(논리적주소)와 MAC주소(물리적주소)를 매칭 시키기 위한 프로토콜
1. host2(목적지) IP 주소를 갖고 있는 Host1은 Host2의 Mac주소를 알아내야 한다
2. host2의 MAC주소를 알아내기 위해 ARP 요청 패킷을 전송한다
3. ARP 요청 패킷이 네트워크 상의 모든 Host에게 broadcast한다
4. 목적지 호스트가 자신의 MAC주소를 포함한 ARP응답 패킷을 보낸다
5. MAC주소 알아내기 성공

## DHCP가 무엇인지 설명해 주세요.
* Dynamic Host Configuration Protocal의 약자로 동적으로 호스트를 설정하는 프로토콜. IP주수의 중복 사용 최소와, 주소 관리를 효율적으로 돕는다.
### DHCP는 몇 계층 프로토콜인가요?
* 7계층 application계층에 속한다. 
### DHCP는 어떻게 동작하나요?
1. Discover : 접속 시도, IP주소 정보 요청
2. Offer : discover 수신, 사용 가능한 IP 주소 할당
3. Request : offer 수신, 사용 가능한 IP주소가 맞는지 확인
4. Ack : 할당받은 IP주소를 사용하여 네트워크 접속
* 이 때 UDP를 사용한다
### DHCP에서 UDP를 사용하는 이유가 무엇인가요?
* TCP는 신뢰성, 연결지향성이 필요할때 사용하나 DHCP에서는 신뢰성보다는 빠른 속도를 요구하기 때문에.
### DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
* 가장 큰 역할은 IP주소 자동 구성이고, 그 이후에는 서브넷 마스크, 기본 게이트웨이, DNS서버정보 등을 제공함

## DNS에 대해 설명해 주세요.
* Domain Name System, 도메인을 IP주소로 변환해주는 시스템. Local DNS, Root DNS, Top level DNS가 있다.
### DNS는 몇 계층 프로토콜인가요?
* 7계층에 속한다.
### UDP와 TCP 중 어떤 것을 사용하나요?
* 연결과 신뢰성보단 빠른 속도를 요구하므로 UCP를 사용한다.
### DNS Recursive Query, Iterative Query가 무엇인가요?
* Recursive Query : DNS서버에 요청을 하면, 해당 DNS서버가 다시 다른 DNS서버에 요청을 하는 재귀적으로 하는 쿼리 작업.
* Iterative Query : DNS서버에 요청을 하고 IP주소를 찾지 못하면, 클라이언트에게 다음 DNS서버에 직접 요청하도록 하여 클라이언트가 반복적으로 쿼리를 요청하는 작업
### DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
* 체크섬, TTL시간이 초과될 경우 재시도
### 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
* DNS캐시를 비우는 것을 통해 가장 간단하게 에러를 보정 할 수 있다.
### DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
* A : 주어진 호스트에 대한 IPv4 주소를 알려줍니다.
* AAAA : 주어진 호스트에 대해 IPv6 주소를 알려준다.
* CNAME : 도메인 이름의 별칭을 만드는 데 사용
### hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
* host파일은 로컬호스트용 DNS. 컴퓨터가 가장 먼저 조회하는 DNS라고 볼 수 있다.

## IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
* 인터넷 프로토콜 주소, 네트워크에 연결된 각 장치를 식별하는 고유한 번호.
### IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
* NAT 사용 : 하나의 공용 IPv4 주소를 여러 개인 네트워크 내의 기기들과 공유하여 사용 할 수 있다.
### IPv4와 IPv6의 차이에 대해 설명해 주세요.
* IPv4는 32비트 주소 체계, 점으로 구분된 십진수, 별도 보안 프로토콜 필요
* IPv6는 128비트 주소 체계, 콜론으로 구분된 16진수, 보안 기능 내장, 향상된 서비스 지원, 단순화된 헤더
### 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
* DHCP(Dynamic Host Configuration Protocal)를 사용해 특정 장치에 고정 IP를 설정할 수 있다.
### IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
* 듀얼 스택 : 네트워크 장비나 서버가 IPv4와 IPv6 주소를 동시에 가지고 있어, 주 프로토콜을 모두 지원
* 터널링 : IPv6패킷을 IPv4 네트워크상에서 전송할 수 있도록 캡슐화 하는것. IPv6 패킷이 IPv4 네트워크를 통과할 때 사용
* 헤더 변환 : IPv4와 IPv6간에 헤더 정보를 변환하여 서로 통신할 수 있게 한다.
### IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
* IP주소 자체는 데이터가 신뢰성을 보장하지 않기에 패킷이 손실되거나 순서가 바뀌는 경우가 있다.
### IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
* IPv4 : IP패킷의 헤더 부분만을 대상으로 오류 검사. 헤더가 손상된 경우 폐기한다.
* TCP 체크섬 : TCP 세그먼트의 전체 내용에 대한 오류를 검사한다.
### TTL(Hop Limit)이란 무엇인가요?
* IP 패킷이 무한정으로 떠돌지 않도록 거칠 수 있는 라우터의 최대 개수
### IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
* IP는 네트워크상에서 단말을 구분하기 위해 부여된 논리적 주소, MAC은 하드웨어 장치에 부여된 고유한 물리적 주소.

## 3-Way Handshake에 대해 설명해 주세요.
* TCP/IP 통신에서 두 장치간의 안정적인 연결을 수립하기 위한 과정. 클라이언트가 서버에게 연결을 시작하겠다는 SYN, 서버가 요청을 받고 준비가 되었다는 SYN-ACK, 클라이언트가 서버의 요청을 받고 준비가 되었다는 ACK과정으로 이루어진다.
### ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
* TCP 패킷의 헤더에 포함되어 전달된다.
### 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
* 양 측에서 ACK 신호를 받는 과정을 거침으로서 신뢰성을 파악할 수 있다.
### 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
* 동시에 연결을 시도하면 각각 SYN패킷을 보내고, 그에대한 ACK패킷을 보내 양방향 연결을 한다.
### SYN Flooding 에 대해 설명해 주세요.
* 공격자가 서버에 대량의 TCP SYN 요청을 보내 서버의 리소스를 고갈시키는 공격. SYN을 보낸 후 SYN-ACK 패킷이 도착하면 그에 따른 ACK신호를 보내지 않음으로서 서버를 대기상태로 두어 리소스를 고갈시킨다. SYN Cookie를 통해 해결 할 수 있다.
### 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
* 이전에 성공적으로 수립된 연결에서 생성된 세션 키를 저장하여, 서버에 암호화된 데이터를 바로 전송함으로서 가능하다.

## 4-Way Handshake에 대해 설명해 주세요.
* TCP/IP 통신에서 연결을 해제하기 위한 과정이다.
* 연결을 종료하겠다는 FIN 플래그를 보내고, 서버는 FIN을 확인했다는 ACK를 보낸 후 자신의 통신이 종료되면 FIN 패킷을 보낸다. 이후 클라이언트는 FIN을 받고 ACK를 보낸 후, 서버는 ACK를 받고 소켓을 닫는다.
### 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
* FIN 플래그를 통해 알 수 있다.
### 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
* RST 플래그를 사용해 연결을 즉시 종료한다. 다만 이 방법을 사용한다면 미처 전송되지 않는 데이터가 손실 될 수 있다.
### 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
* Timeout을 통해 일정 시간이 지나면 스스로 Close한다.
### 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
* 클라이언트에서 서버로 보낸 ACK가 소실되었을 수가 있고, 서버에서 아직 받지 못한 잉여 패킷이 있을 수 있다.

## SOP 정책에 대해 설명해 주세요.
* Same Origin Policy : 다른 origin(프로토콜, 도메인(IP), 포트)의 문서가 상호작용하는것을 막는 것. 보안과 개인정보보호를 위해 사용된다.
### CORS 정책이 무엇인가요?
* Cross Origin Resource Sharing : SOP의 제한을 완화하는 메커니즘으로, 다른 출처의 리소스에 접근할 수 있도록 한다.
### Preflight에 대해 설명해 주세요.
* CORS 정책을 준수하는 웹 브라우저가 다른 출처의 서버로 요청을 보내기 전에, 해당 서버가 본 요청을 안전하게 처리할 수 있는지를 확인하기 위해 먼저 보내는 HTTP OPTIONS 요청. OPTIONS요청을 사용해 예비요청을 보내며, 실제 요청에 사용될 HTTP 메서드와 헤더 정보가 포함됨. 이에 대해 서버는 CORS관련 헤더를 포함한 응답을 보낸 후, 허용되었다면 서버가 실체 요청을 보냄.