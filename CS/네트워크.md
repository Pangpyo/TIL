# 네트워크
## TCP와 UDP
* OSI 4계층에서 사용하는 통신 프로토콜
### TCP
* 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부 확인
* 연결형
* 3 way handshake(연결)
  1. SYN단계 : 클라이언트의 ISN을 담아 SYN을 보냄
  2. SYN+ACK 단계 : 서버는 클라이언트의 SYN 수신 후 서버의 ISN과 클라이언트의 ISN+1을 담아 SYN을 보냄
  3. ACK 단계 : 클라이언트는 서버의 ISN+1 값인 승인번호를 담아 ACK를 보냄
* 4 way handshake(연결 해제)
  1. 클라이언트가 FIN을 보내고 서버의 응답을 기다림
  2. 서버는 ACK를 보냄
  3. 일정 시간 후 서버는 FIN을 클라이언트에 보냄
  4. 클라이언트는 서버로 ACK를 보내고 연결해제
### UDP
* 신뢰성이 보장되지 않기에 데이터 손실 가능성이 있음
* 신뢰성 확인을 하지 않기에 TCP에 비해 용량이 가볍고 송신 속도가 빠름
* 비 연결형
## HTTP
* HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. 하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다. HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.
### 특징
* 요청과 응답 두 가지 유형이 있음
* 헤더와 바디로 이루어짐
* 무상태성
  * 클라이언트와 서버 간에 상태 정보를 들고있지 않음
* 비연결성
  * 한번 통신 후 연결이 끊어짐
### HTTPS
* 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
* SSL handshake
  1. Client Hello 
    * 브라우저가 사용하는 암호화 정보와 알고리즘을 보냄
  2. Server Hello
    * 사용 가능한 알고리즘 선택, SSL인증서(공개키와 서버의 신원정보를 포함) 클라이언트로 전달
  3. 서버 인증서를 발행 기관을 통해 검증
  4. Premeter Secret
    * 대칭키 생성 후 서버로 전송
  5. Premeter Secret 복호화
  6. SSL handshake 종료 및 HTTPS 통신 시작

### HTTP 메소드
* 주요 메소드
  * GET : 리소스 조회
  * POST : 요청 데이터 처리, 주로 등록에 사용
  * PUT : 리소스를 대체, 해당 리소스가 없다면 생성
  * PATCH : 리소스 부분 변경
  * DELETE : 리소스 삭제
* 기타 메소드 
  * HEAD : GET과 동일하지만 메시지부분을 제외하고 상태줄과 헤더만 반환
  * OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
  * CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
  * TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행
* HTTP 메서드의 멱등성
  * HTTP 메서드중 GET, PUT, DELETE 등은 여러번 수행되어도 결과가 같은 멱등성을 가진다

### Rest란?
* Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것
* 이러한 규칙을 지켜 만든 API를 Restful API라고 한다.
* HTTP URI를 통해 자원을 명시하고, Method를 통해 해당 자원에 대한 동작을 적용한다.
* 장점
  * 쉬운 사용성 : API의 의도를 쉽게 파악 가능
  * 클라이언트와 서버의 분리
  * 데이터의 명확한 표현
* 단점 
  * 메서드 형태가 제한적
  * 표준이 명확하지 않음

## 프록시 서버란?
* 클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 중간에 대신 전달해주는 서버
### 프록시서버 사용 이유
* 보안 : 서버의 IP를 숨기는 것이 가능
* 캐시 : 이전에 했던 요청들을 프록시서버에 캐싱해둘수 있다
### 포워드 프록시
* 클라이언트에서 요청을 할 때 직접 요청하는 것이 아닌 프록시서버를 거치는 방식이 포워드 프록시
* 캐싱, 보안을 위해 사용
### 리버스 프록시
* 서버에서 클라이언트에 직접 데이터를 전달하지 않고 프록시서버를 거치는 방식이 리버스 프록시
* 캐싱, 보안, 로드밸런싱
* nginx를 사용해 리버스 프록시 서버 사용 가능

### DNS서버란?
* 도메인 네임 시스템은 호스트의 도메인 네임을 네트워크 주소로 변환하거나, 그 반대의 역할을 수행하는 시스템이다.
* Local DNS(기지국 DNS) 서버란?
  * 인터넷을 사용하기 위해서는 IP를 할당해주는 통신사에 등록해야한다. 이후 컴퓨터가 LAN선을 통해 연결되면, 가입했던 통신사의 기지국 DNS서버가 등록되게 된다. 

# 네트워크 심화질문

## 쿠키와 세션의 차이에 대해 설명해주세요.
* 쿠키와 세션 :  HTTP는 상태를 저장하지 않기때문에, 상태를 저장하기 위해 사용한다.
* 쿠키 : 클라이언트에 키와 값으로 저장된다.
* 세션 : 쿠키를 기반으로 하지만, 쿠키로는 세션ID만을 저장하고 필요한 데이터는 서버에 저장한다. 서버 부하가 심하지만, 쿠키에 비해 보안이 강력하다.
### 세션방식의 로그인 방식에 대해 설명해주세요.
* 클라이언트에서 인증(로그인)이 이루어 졌을 때, 서버에서는 쿠키에 세션ID를 담아 클라이언트측에 보내면 로그인이 완료된다.
* 로그인 이후 해당 세션ID를 가지고 서버에 인가 요청을 한다. 그러면 사용자에 따른 응답을 한다.
### HTTP의 특성인 Stateless에 대해 설명해주세요.
* 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. 그렇기에 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
* 세션은 어느정도 stateless 원칙을 위반하는 측면이 있다. 하지만 매번 모든 정보를 클라이언트에서 함께 요청하다보면, 더 많은 데이터가 소모된다. 그렇기에 꼭 필요한 경우에는 어느정도 상태 유지를 사용해야만 한다.
### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
* 서버 모두가 세션을 공유해야 하기 떄문에 세션 저장소를 두어 모든 서버에서 해당 저장소를 바라보게 하면된다. 오류를 대비해 백업용 세션 저장소까지 준비하면 좋다.
### JWT에 대해 설명해주세요.
* 한번 인증 후에 서버가 클라이언트에 토큰을 부여한다. 이후 이를 통해 상태를 유지할 수 있고, 유저의 인증과 같은 상태를 해결할 수 있다. payload 자체는 암호화 되지 않기에 중요한 정보를 담을 수는 없고, 탈취시에 위험이 있다. 이를 유효기간을 설정하는 것으로 막을 수 있다.
### 인증과 인가의 차이
* 인증 : 사용자의 신원을 확인하는 과정.(예, 로그인)
* 인가 : 이미 인증된 사용자의 권한을 기반으로 자원에 대한 접근을 확인하는 것

## HTTP 응답코드
* HTTP 요청에 대한 처리 여부를 알려준다.
* 1xx : 정보 응답 : 처리가 되었으니 다음으로 진행하라는 응답 코드. 클라이언트에서 `expect` 헤더를 넣어줘야한다.
  * 100 Continue : 지금까지의 상태가 괜찮음
  * 101 Swiching Protocol : 클라이언트가 보낸 요청 헤더에 대한 응답에 들어가며 서버에서 프로토콜을 업데이트 할 때(웹소켓으로 전환하는 등)
  * 102 Processing : 처리중일 때
* 2xx : 요청이 정상적으로 처리됨
  * 200 OK : 성공적으로 처리
  * 201 Created : 새로운 리소스가 생성됨
  * 202 Accepted : 요청은 허용되었지만, 처리가 완료되지 않음(처리가 오래 걸릴 경우 비동기로 처리하여 나중에 알려주겠다는 의미, 완료 예측 시간 등을 포함한다)
  * 204 No Content : 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없음
* 3xx : 리다이렉션, 추가적인 작업(페이지 이동이 필요함)
  * 300 Multiple Choices : 가능한 응답이 여러개이다.(거의 사용되지 않음)
  * 301 Moved Permanetly : 영구적인 이동(영구 리다이렉션), 해당 URL로 리다이렉션 되고 GET메서드로 변한 후 본문이 제거될 수 있다.
  * 302 Found : 다른 위치 찾음, 일시적인 리다이렉션(검색엔진에서 301과 차이 있음)
  * 303 See Other : 다른 위치 보기(다른 메서드로의 변경과 본문 제거 행위가 보장됨)
  * 307 Temporary Rediect : 임시로 리다이렉션 요청이 필요하다
  * 308 Permanent Redirect : 영구 리다이렉션, 본문을 유지함
* 4xx : 클라이언트 에러. 잘못된 문법 등으로 서버가 요청을 수행 할 수 없고, 원인이 클라이언트에 있을 때
  * 400 Bad Request : 요청이 잘못되었다. 요청구문, API 스펙이 맞지 않을 때.
  * 401 Unauthorized : 리소스에 대한 인증이 없어 접근할 수 없을 때.
  * 403 Fobidden : 인증은 되었으나, 인가가 되지 않았을 때.
  * 404 Not Found : 지정한 리소스를 찾을 수 없다. 요청한 자원이 존재하지 않을 때.
  * 410 Gone : 요청한 리소스가 서버에서 영구히 삭제되어 존재하지 않을 때.
* 5xx : 서버 에러
  * 500 Internal Server Error : 서버에 에러가 발생하였다
  * 501 Not Implemented : 해당 URI의 메서드가 서버에서 구현되지 않음
  * 502 Bad Gateway : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다. 보통 서버 폭주 등의 원인이 있다.

### 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
* 사용자가 임의로 http 응답코드를 만들어서 사용하는 경우, 서버와 클라이언트 양 측에서 해당 코드에 대한 정보가 있어야한다. 그렇지 않으면 클라이언트에서는 xx0코드로 처리된다.


## HTTP 메서드에 대해 설명해주세요
* HTTP는 여러 가지 메서드를 정의하여 클라이언트가 서버에게 요청을 보내고 서버가 해당 요청에 응답하는 방식을 결정.
* GET : 리소스를 가져오기 위해 사용.
* POST : 새로운 데이터를 제출하기 위해 사용.
* PUT : 지정된 위치에 리소스를 저장하거나 업데이트하기 위해 사용.
* DELETE : 지정된 리소스를 삭제하기 위해 사용.
* PATCH : 리소스의 부분적인 업데이트를 위해 사용
* HEAD : GET과 유사하지만 헤더만을 반환.
* OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
### HTTP Method의 멱등성에 대해 설명해 주세요.
* 몇 HTTP 메서드들은 여러번 실행되어도 같은 결과를 가진다. 이를 멱등성이라고 한다.
### GET과 POST의 차이는 무엇인가요?
* 용도로 따지면 GET은 리소스를 조회할 때, POST는 새로운 데이터를 제출할 때 사용한다. 또한 GET은 데이터를 URL의 쿼리 문자열에 포함하여 서버로 전송하며, POST는 본문에 포함하여 전송한다. 또한 GET요청은 캐싱을 통해 성능 향상을 노려볼 수 있으며, POST는 일반적으로 캐싱하는것이 의미가 없다.
### POST와 PUT, PATCH의 차이는 무엇인가요?
* 용도로는 생성과 수정이라는 차이를 가진다. 실제 동작에서는, POST는 특정 자원을 목적으로 하는 것이 아니므로, 새로운 데이터가 생성되며 멱등성을 가지지 않는다. 하지만 PUT은 특정 자원을 상대로 하므로, 만약 이전에 없던 데이터에 대해 사용하더라도 멱등성을 가진다. PATCH는 자원의 일부만을 수정하며, 멱등성을 처리에 따라 멱등성을 가지지 않기도 한다.
### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
* 일반적으로 GET요청은 캐싱을 할 수 있다. 하지만 GET에 Body가 포함되면 캐싱이 어려워지거나 일관성이 깨질 수 있다. 몇몇 서버나 미들웨어는 Get요청의 Body를 처리하지 못할 수도 있으며, 또한 Restful 설계원칙에 맞지 않게 된다.
### Get요청의 캐시
* last modified date, etag(리소스 변경시마다 바뀌는 고유ID)를 통해 캐시가 유효한지 판단하여, 캐시를 사용한다.

## HTTP에 대해 설명해주세요.
* Hyper Text Transfer Protocol로, 서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규약.
* HTML, TEXT, IMAGE, 음성, 영상, JSON등의 데이터를 전송할 수 있다.
* 클라이언트가 요청하면 서버가 응답한다. 
* 헤더와 바디로 이루어진다.
* 무상태성(stateless) : 클라이언트와 서버 사이에 상태를 유지하지 않는다.
* 비연결성(connectionless) : 클라이언트와 서버 사이에 연결을 지속하지 않는다.
### 공개키와 대칭키에 대해 설명해 주세요.
* 대칭키 : 키가 동일한 암호화 방식. 해당 키를 알아야만 문서를 복호화해 볼 수 있게된다. 수행시간이 짧지만, 안전한 키교환 방식이 요구된다.
* 공개키 : 대칭키의 키교환 문제를 해결하기 위해 등장한것이 공개키이다. 공개키로 암호화, 개인키로 복호화한다. 속도가 느린 단점이 있다.
### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
* 서버의 인증서를 통해 서버의 신원을 확인할 수 있고, 공개키를 통해 안전하게 대칭키를 공유할 수 있다.
### SSL과 TLS의 차이는 무엇인가요?
* 둘 모두 보안을 위한 프로토콜.
* SSL은 사실상 종료되었으며, TLS는 SSL에서 보다 더 안전한 암호화 알고리즘을 사용한다. (RC4 > AES) 또한 더욱 엄격한 인증서 검증 과정을 거친다.

## 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
* 소켓 통신 : TCP/IP 프로토콜을 이용하여 데이터를 송수신하는 연결부를 의미한다. 전송계층에서 작동한다. 송신버퍼와 수신버퍼를 가지고있다.
* 웹소켓 : HTTP 레이어에서 작동하며, 소켓을 이용해 실시간 양방향 통신을 가능하게 한다. 애플리케이션 계층에서 메시지를 주고 받는다.
### 소켓통신 과정에 대해 설명해주세요.
* `socket()` 함수로 소켓 생성, `bind()`함수로 ip주소와 포트번호 설정, `listen()`함수로 몇 개의 클라이언트를 대기시킬지 결정, `accept()` 함수로 클라이언트와 연결을 기다림 `send()`, `recv()`로 데이터를 송수신한다.
### 소켓과 포트의 차이가 무엇인가요?
* 소켓 : 네트워크에서 두 대의 프로세스간의 데이터 송수신을 위한 통신 엔드포인트. 소켓을 열기 위해서는 호스트에 할당된 IP 주소, 포트넘버, 프로토콜이 필요하다.
* 포트 : 네트워크에서 특정 소프트웨어의 데이터를 전달하기 위한 통신 채널을 식별하는 번호. 호스트 내부적으로 프로세스가 할당받는 고유한 값이다.
### 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
* 하나의 프로세스는 같은 IP주소, 같은 프로토콜, 같은 포트넘버를 가지는 여러개의 소켓을 가질 수 있다.
  * ex : 하나의 서버가 여러개의 클라이언트와 통신하는 경우
* 이 여러개의 소켓은 고유의 소켓 디스크립터를 가지기에 판별할 수 있다.
### 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
* 웹 서버는 일반적으로 동시에 열 수 있는 소켓의 수를 제한하고, 요청을 처리한 후에는 소켓을 종료하기에 무수히 많은 소켓이 생성되지는 않는다. 소켓도 파일이기에 파일디스크럽터의 제한에 따라 그만큼의 소켓만 생성 될 수 있다.

## HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
* HTTP/1.1
  * 연결 한 개당 하나의 요청을 처리하도록 설계됨.
    * 요청과 응답이 순차적으로 이루어짐. 동시에 리소스를 주고 받는것이 불가능, 다수의 리소스를 처리하려면 대기시간이 길어짐
  * HOL(Head Of Line) Blocking이 발생할 수 있다.
    * 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * RTT(Rount Trip Time) : 매번 요청별로 연결을 만들게 되고, 3-way handshake가 반복적으로 일어나며 불필요한 RTT의 증가와 네트워크 지연을 초래
  * 무거운 Header 구조 : 매 요청마다 중복된 헤더 값을 전송하며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송
* HTTP/2
  * Multiplexed Streams : 연결 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며 응답은 순서에 상관 없이 스트림으로 받는다. 이 때 스트림 내의 여러 패킷들은 헤더의 stream id를 통해 구분하여 신뢰성을 보장 할 수 있다.
  * Stream Prioritization : 리소스간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결 할 수 있다. 의존관계로는 해당 문서에 필요한 CSS파일이나 JS파일을 보내는 것.
  * Server Push : 클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다. 
  * Header Compression : 헤더의 중복이 발생할 경우 Static/Dynamic Header Talbe 개념을 이용해 중복을 검출하고, 중복되지 않은 index값 + Header 정보를 허프만 인코딩 방식으로 데이터를 전송한다. header table/ 중복되는경우 index, 변경필드는 허프만 인코딩
### HOL Blocking 에 대해 설명해 주세요.
* 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * HTTP/1.1에서는 연결 한개당 하나의 요청만을 처리하기 때문에 발생
  * HTTP/2에서는 패킷이 손실되어 재전송되는 동안, 뒤에 오는 패킷들은 대기상태가 되어 발생(순서를 보장해야하기 때문에)
### HTTP/3.0의 주요 특징에 대해 설명해 주세요.
* 반복된 Handshake 과정에서 발생하는 지연시간과 재전송으로 인한 HOL Blocking을 해결하기 위해 TCP 프로토콜 대신 QUIC 프로토콜을 사용한다.
 * TCP의 구조적 한계
  * TCP는 신뢰성을 위해 패킷을 순서대로 처리해야함, 이로 인해 패킷이 중간에 유실되거나 수신측의 패킷 파싱 속도가 느리다면 병목이 발생한다
  * UDP는 패킷의 목적지만 정해진다면 중간 경로를 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요 없음.
* QUIC 프로토콜 : Quick UDP Internet Conntections, 즉 UDP기반의 프로토콜
  * 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서대로 재조립할 수 있게 한다.
  * 또한 checksum을 사용해 패킷의 무결성을 보장한다.
  * SSL/TSL 인증서도 포함되어 있다.

## TCP와 UDP의 차이에 대해 설명해 주세요.
* TCP(Transmission Control Protocol) : 연결형 서비스, 흐름제어와 혼잡제어를 사용하며 패킷 손실 방지. 데이터의 순서와 신뢰성을 보장
  * 흐름제어 : 송신측과 수신측의 데이터 처리 속도를 해결하기 위한 방법. 수신측이 너무 많은 패킷을 수신받지 않도록 한다. 수신측에는 패킷을 수신받는 버퍼의 크기가 정해져 있기 때문이다. 수신측이 자신의 상태를 계속 송신측에 알림으로써 진행된다.
  * 혼잡제어 : 네트워크 내의 혼잡 상태를 감지하여, 이에 따라 전송 속도를 조절한다.
* UDP(User Datagram Protocol) : 비연결형 서비스, 데이터의 순서와 신뢰성을 보장하지 않음. 헤더의 크기가 작아 처리가 빠르고, 실시간 서비스에 적합하다. DNS조회, 스트리밍 등에 주로 사용된다. 데이터그램 방식을 사용한다.
  * 데이터그램 : 패킷의 유형, 연결 절차가 없고, 독립적인 관계를 가진다.
### Checksum이 무엇인가요?
* Checksum : 송신된 자료의 무결성을 보호하는 방법. 나열된 데이터를 더하여 체크섬 숫자를 얻고, 2의 보수를 얻어 체크섬 바이트를 얻는다. 이 체크섬 바이트와 원래 그룹의 바이트를 더함으로써 무결성을 체크할 수 있다.
### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
* 둘 다 체크섬을 수행 할 수 있지만, TCP는 필수이고 UDP는 선택적이다.
### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
* 데이터의 무결성을 확인 할 수 있지만, 오류를 정정할수는 없다.
### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
* 각 데이터 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서로 재조립할 수 있게 하며, 체크섬을 사용하여 오류가 있는지 확인하고 일치하지 않으면 재전송을 요청한다.
### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
* AIMD(Additive increase multiplicative decrease) : 각 연결마다 윈도우 크기를 설정한다. 성공적으로 수신하면 1 증가시키고, 실패하면 절반으로 감소한다. 안정성이 높지만, 지나친 감쇠로 감소가 크게 발생할 수 있다.
* Slow Start : 윈도우 사이즈를 2배씩 증가시키고, 혼잡현상이 한번 발생하면 1씩 증가시킨다. 너무 빠른 증가로 네트워크 혼잡이 초래될 수 있다.
### 왜 HTTP는 TCP를 사용하나요?
* TCP의 신뢰성의 때문에. 
### 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
* HOL 블로킹을 해결하기 위해 UDP를 사용한다. 패킷이 순서대로 도착해야함에 의한 시간 소요와 연결, 연결 해제를 위한 시간 소요를 줄이기 위해 사용한다. UDP에서 QUIC프로토콜을 사용함으로써 신뢰성을 확보한다.
### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
* 일반적으로는 TCP를 사용하며, HTTP/3에서는 UDP를 사용한다. 이 때 Alt-Svc(alternative service) 헤더 응답에 h3응답이 있으면 udp포트에서 http/3을 사용할 수 있음을 알 수 있다. 혹은, tcp요청과 udp요청을 동시에 보내어 먼저 온 응답으로 판단하기도 한다.
### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
* QUIC 프로토콜을 사용하기 위해서는 클라이언트에서 더 많은 처리를 필요로 하므로 필요 하드웨어 사양이 높아지게 된다. 그렇기에 하드웨어 사양과 요구 속도, 신뢰성 여부 등을 파악해 선택하겠다. 또한 TCP를 사용한다면 기존에 있는 헤더들을 재활용하는 방향으로 가야 할 것이고, UDP를 사용한다면 이러한 기능들을 개발자가 개발해야 하기에, 이런 기준들을 생각 할 것이다.

## OSI 7계층에 대해 설명해 주세요.
1. 물리계층(Physical Layer) : 데이터 전송 매체를 통해 신호를 전기적 신호로 변환하고 비트 스트림을 전송한다.
  * 케이블, 리피터, 허브
2. 데이터 링크 계층(Data Link Layer) : 물리적 네트워크를 통해 프레임을 전송하고 오류검출 및 재전송을 담당합니다. 맥 주소를 가지고 통신을 한다.
  * 브릿지와 스위치
3. 네트워크 계층(Network Layer) : 경로를 선택하고 경로에 따라 패킷을 전달한다. 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)을 담당한다. IP주소를 사용한다.
  * 라우터
4. 전송 계층(Transport Layer) : 통신을 활성화하기 위한 계층. TCP와 UDP프로토콜이 대표적이다.
  * TCP, UDP
5. 세션 계층(Session Layer): 데이터가 통신하기 위한 논리적인 연결. 애플리케이션간의 세션을 관리하고 데이터 교환 동기화를 담당한다.
6. 표현 계층(Presentation Layer) : 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다. 데이터의 인코딩과 암호화 등의 동작이 이루어짐
  * SSL/TLS 암호화
7. 응용 계층(Application Layer) : 최종 목적지로서 응용 프로세스와 직접 관계하여 일반적인 응용 서비스 수행.
  * HTTP
### OSI 7계층에서 캡슐화와 역캡슐화
* 송, 수신시 방향에 따라 헤더를 추가하면서 캡슐화하고, 헤더를 제거하면서 역캡슐화한다.
### Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
* 전송계층은 TCP통신 등을 사용하여 신뢰성있게 전달될 수 있는지를 관리한다. 네트워크 계층은 IP주소를 기반으로 데이터가 어디로 가야 하는지를 결정한다.
### L3 Switch와 Router의 차이에 대해 설명해 주세요.
* 거의 동일한 의미로 사용할 수 있다.
### L3과 L4는 각각 어떤 기준으로 통신을 하나요?
  * L3은 IP, L4는 포트
### 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
* 물리계층은 비트, 데이터 링크 계층은 프레임, 네트워크 계층은 패킷, 전송 계층은 세그먼트, 세션은 데이터, 표현, 응용 계층은 메시지라고 한다.
### ARP에 대해 설명해 주세요.
* Adress Resolution Protocol
* IP주소(논리적주소)와 MAC주소(물리적주소)를 매칭 시키기 위한 프로토콜
* 2계층
1. host2(목적지) IP 주소를 갖고 있는 Host1은 Host2의 Mac주소를 알아내야 한다
2. host2의 MAC주소를 알아내기 위해 ARP 요청 패킷을 전송한다
3. ARP 요청 패킷이 네트워크 상의 모든 Host에게 broadcast한다
4. 목적지 호스트가 자신의 MAC주소를 포함한 ARP응답 패킷을 host1에게 보낸다
5. MAC주소 알아내기 성공
* L2 > 내부망 해킹

## DHCP가 무엇인지 설명해 주세요.
* Dynamic Host Configuration Protocal의 약자로 동적으로 호스트를 설정하는 프로토콜. IP주소의 중복 사용 최소와, 주소 관리를 효율적으로 돕는다.
### DHCP서버의 IP는 누가 할당하나요?
* ISP가 할당한다.
### DHCP는 몇 계층 프로토콜인가요?
* 7계층 application계층에 속한다. DHCP서버가 클라이언트에게 IP주소, 서브넷마스크, 기본 게이트웨이, DNS서버 정보 등을 제공한다. 이런 기능들은 application 계층에서 수행된다.
### DHCP는 어떻게 동작하나요?
1. Discover : 접속 시도, IP주소 정보 요청(브로드캐스트)
2. Offer : discover 수신, 사용 가능한 IP 주소 할당(브로드캐스트or유니)
3. Request : offer 수신, 사용 가능한 IP주소가 맞는지 확인(브로드캐스트)
4. Ack : 할당받은 IP주소를 사용하여 네트워크 접속(브로드or유니)
* 이 때 UDP를 사용한다
### DHCP에서 UDP를 사용하는 이유가 무엇인가요?
* 특정한 dhcp와 통신하는 것이 아닌, 어디 있는지 모를 dhcp서버들과 통신하기에 브로드캐스트를 해야한다. 이 때, 1:1연결인 TCP는 사용할 수 없다.
### DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
* 가장 큰 역할은 IP주소 자동 구성이고, 그 이후에는 서브넷 마스크, 기본 게이트웨이, DNS서버정보 등을 제공함
### DHCP가 할당한 IP의 유효기간
* DHCP마다 다르며, 몇시간에서 몇일

## IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
* 인터넷 프로토콜 주소, 네트워크에 연결된 각 장치를 식별하는 고유한 번호.
* 맥 주소로만 통신하면, 그 과정이 오래걸리기에 IP주소로 관리하여 더 빠른 접근을 할 수 있다.
### IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
* NAT(Network Adress Translation) 사용 : 하나의 공용 IPv4 주소를 사설 IP를 통해 여러 개인 네트워크 내의 기기들과 공유하여 사용 할 수 있다.
### IPv4와 IPv6의 차이에 대해 설명해 주세요.
* IPv4는 32비트 주소 체계, 점으로 구분된 십진수, 별도 보안 프로토콜 필요
* IPv6는 128비트 주소 체계, 콜론으로 구분된 16진수, 보안 기능 내장, 향상된 서비스 지원, 단순화된 헤더
### 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
* DHCP(Dynamic Host Configuration Protocal)를 사용해 특정 장치에 고정 IP를 설정할 수 있다.
### IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
* 듀얼 스택 : 네트워크 장비나 서버가 IPv4와 IPv6 주소를 동시에 가지고 있어, 주 프로토콜을 모두 지원
* 터널링 : IPv6패킷을 IPv4 네트워크상에서 전송할 수 있도록 캡슐화 하는것. IPv6 패킷이 IPv4 네트워크를 통과할 때 사용
* 헤더 변환 : IPv4와 IPv6간에 헤더 정보를 변환하여 서로 통신할 수 있게 한다.
### IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
* IP주소 자체는 데이터가 신뢰성을 보장하지 않기에 패킷이 손실되거나 순서가 바뀌는 경우가 있다.
### IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
* IPv4 : IP패킷의 헤더 부분만을 대상으로 오류 검사. 헤더가 손상된 경우 폐기한다.
* TCP 체크섬 : TCP 세그먼트의 전체 내용에 대한 오류를 검사한다.
### TTL(Hop Limit)이란 무엇인가요?
* IP 패킷이 무한정으로 떠돌지 않도록 거칠 수 있는 라우터의 최대 개수
### IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
* IP는 네트워크상에서 단말을 구분하기 위해 부여된 논리적 주소, MAC은 하드웨어 장치에 부여된 고유한 물리적 주소. IP주소는 변경 가능하고 연속성을 가지기에 라우팅에 효과적이다.
  * MAC주소에는 라우팅에 필요한 구조적 정보를 가지지 않기에, 찾아가는 시간이 너무 오래 걸릴 수 있다. IP는 계층적 정보를 가지기에 더 빠르게 해당 위치를 식별할 수 있다.
### IP와 TCP의 역할의 차이가 뭘까요?
* 주소를 지정하는 역할을 IP가 하고, 이 과정에서 신뢰성 있는 연결을 TCP가 담당한다.
### ICMP 정의, 활용도
* TTL에서 중간에 막히게 되면, 막힌 라우터에서 다시 데이터를 보낸다.

## 3-Way Handshake에 대해 설명해 주세요.
* TCP/IP 통신에서 두 장치간의 안정적인 연결을 수립하기 위한 과정. 클라이언트가 서버에게 연결을 시작하겠다는 SYN, 서버가 요청을 받고 준비가 되었다는 SYN-ACK, 클라이언트가 서버의 요청을 받고 준비가 되었다는 ACK과정으로 이루어진다.
### ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
* TCP 패킷의 헤더(flag필드)에 포함되어 전달된다.
### flag필드에 대해 설명해주세요.
* 연결의 상태를 의미한다. (syn, ack, fin) 등
### 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
* 양 측에서 ACK 신호를 받는 과정을 거침으로서 신뢰성을 파악할 수 있다.
### 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
* 동시에 연결을 시도하면 각각 SYN패킷을 보내고, 그에대한 ACK패킷을 보내 양방향 연결을 한다.
### SYN Flooding 에 대해 설명해 주세요.
* 공격자가 서버에 대량의 TCP SYN 요청을 보내 서버의 리소스를 고갈시키는 공격. SYN을 보낸 후 SYN-ACK 패킷이 도착하면 그에 따른 ACK신호를 보내지 않음으로서 서버를 대기상태로 두어 리소스를 고갈시킨다. SYN Cookie를 통해 해결 할 수 있다. SYN Proxy, 방화벽 사용이 있을 수 있다.
* SYN Proxy : SYN Proxy는 방화벽이나 로드밸런서에서 구현되며, 서버에 도달하기 전 클라이언트의 요청을 검증한다.
### 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
* 이전에 성공적으로 수립된 연결에서 생성된 세션 키를 저장하여, 서버에 암호화된 데이터를 바로 전송함으로서 가능하다.
* 이 때, 특정 서버와의 세션 키를 쿠키로 둔다.

## 4-Way Handshake에 대해 설명해 주세요.
* TCP/IP 통신에서 연결을 해제하기 위한 과정이다.
* 연결을 종료하겠다는 FIN 플래그를 보내고, 서버는 FIN을 확인했다는 ACK를 보낸 후 자신의 통신이 종료되면 FIN 패킷을 보낸다. 이후 클라이언트는 FIN을 받고 ACK를 보낸 후, 서버는 ACK를 받고 소켓을 닫는다.
### 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
* FIN 플래그를 통해 알 수 있다.
### 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
* RST 플래그를 사용해 연결을 즉시 종료한다. 다만 이 방법을 사용한다면 미처 전송되지 않는 데이터가 손실 될 수 있다.
### 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
* Timeout을 통해 일정 시간이 지나면 스스로 Close한다.
### 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
* 클라이언트에서 서버로 보낸 ACK가 소실되었을 수가 있고, 서버에서 아직 받지 못한 잉여 패킷이 있을 수 있다.

## naver.com을 치면 일어나는 일
### 네트워크 흐름 측면에서
1. 사용자가 브라우저에 도메인 네임 `www.naver.com` 을 입력한다.
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3. 페이지 URL 정보와 전달 받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이 과정에서 소켓과 포트가 사용되며, 소켓은 IP주소와 포트번호, 사용할 프로토콜(TCP)의 조합으로 네트워크 서비스를 사용하는데 필요한 엔드포인트이다. HTTP는 80, HTTPS는 443포트로 연결 요청을 보낸다.
4. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력 되어 사용자가 볼 수 있게 된다.

### DNS서버 에서
1. 브라우저가 캐시에서 `www.naver.com`에 대응되는 IP주소가 존재하는지 확인한다
  * 브라우저 자신이 저장하고 있는 캐시를 가장 먼저 탐색한다
  * 이후 os에 저장된 캐시를 탐색한다. (윈도우의 host 파일)
  * 라우터(공유기)에 저장되어 있는 캐시 정보를 탐색한다
  * local DNS서버의 캐시를 확인한다
2. local DNS서버에서 `www.naver.com`에 대응되는 IP주소 정보를 요청한다
3. Root DNS 서버는 .com으로 끝나는 도메인에 대한 DNS정보가 담긴 서버의 IP주소를 반환
4. 반환받은 주소를 통해 .com DNS서버로 다시 `www.naver.com`에 대한 IP주소 정보 요청
5. .com DNS서버는 `naver.com` 도메인에 대한 정보가 담긴 서버의 IP 주소 반환
6. `naver.com` DNS서버는 `www.naver.com` IP주소가 저장되어있어 해당 IP주소를 반환한다.
7. 이 때 DNS서버의 쿼리는 naver.com의 웹 서버를 가리키고 있다.
### Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
* WS : 정적 컨텐츠(HTML 페이지)를 처리하고 사용자에게 전송한다. 대표적으로 Apache, nginx 등이 있다.
* WAS : 동적 컨텐츠를 처리하며, 사용자의 요청에 따라 서버 측에서 프로그램을 실행하여 결과를 생성한다. Tomcat 등이 있다.
* 둘을 나눔으로써 각각의 서버가 최적화된 작업을 처리 할 수 있다. WAS가 모든 일을 처리한다면, 시스템에 부담이 가중되어 응답 속도가 느려질 수 있고, 보안 취약점이 생길 수 있다.
### URL, URI, URN은 어떤 차이가 있나요?
* URI : 가장 넓은 개념으로, 인터넷의 자원을 식별하는데 사용되는 문자열.
* URL : 자원이 위치한 곳을 나타내며, 프로토콜을 포함하여 정확한 위치를 나타낸다.
* URN : 위치에 상관 없이 식별 가능한 고유한 이름. 위치가 변하더라도 자원을 이름으로 식별할 수 있다.

## DNS에 대해 설명해 주세요.
* Domain Name System, 도메인을 IP주소로 변환해주는 시스템. Local DNS, Root DNS, Top level DNS가 있다.
### DNS는 몇 계층 프로토콜인가요?
* 7계층에 속한다.
### UDP와 TCP 중 어떤 것을 사용하나요?
* 연결과 신뢰성보단 빠른 속도를 요구하므로 UCP를 사용한다.
### DNS Recursive Query, Iterative Query가 무엇인가요?
* Recursive Query : DNS서버에 요청을 하면, 해당 DNS서버가 다시 다른 DNS서버에 요청을 하는 재귀적으로 하는 쿼리 작업.
* Iterative Query : DNS서버에 요청을 하고 IP주소를 찾지 못하면, 클라이언트에게 다음 DNS서버에 직접 요청하도록 하여 클라이언트가 반복적으로 쿼리를 요청하는 작업
### DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
* 체크섬, TTL시간이 초과될 경우 재시도
### 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
* DNS캐시를 비우는 것을 통해 가장 간단하게 에러를 보정 할 수 있다.
### DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
* A : 주어진 호스트에 대한 IPv4 주소를 알려줍니다.
* AAAA : 주어진 호스트에 대해 IPv6 주소를 알려준다.
* CNAME : 도메인 이름의 별칭을 만드는 데 사용
### hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
* host파일은 로컬호스트용 DNS. 컴퓨터가 가장 먼저 조회하는 DNS라고 볼 수 있다.

## SOP 정책에 대해 설명해 주세요.
* Same Origin Policy : 다른 origin(프로토콜, 도메인(IP), 포트)의 문서가 상호작용하는것을 막는 것. 보안과 개인정보보호를 위해 사용된다.
### CORS 정책이 무엇인가요?
* Cross Origin Resource Sharing : SOP의 제한을 완화하는 메커니즘으로, 다른 출처의 리소스에 접근할 수 있도록 한다.
### Preflight에 대해 설명해 주세요.
* CORS 정책을 준수하는 웹 브라우저가 다른 출처의 서버로 요청을 보내기 전에, 해당 서버가 본 요청을 안전하게 처리할 수 있는지를 확인하기 위해 먼저 보내는 HTTP OPTIONS 요청. OPTIONS요청을 사용해 예비요청을 보내며, 실제 요청에 사용될 HTTP 메서드와 헤더 정보가 포함됨. 이에 대해 서버는 CORS관련 헤더를 포함한 응답을 보낸 후, 허용되었다면 서버가 실체 요청을 보냄.

## Stateless와 Connectionless에 대해 설명해 주세요.
* Stateless : 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. 그렇기에 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
* Connectionless : 클라이언트가 서버에 요청을 하고 응답을 받으면 연결을 끊어 연결을 지속하지 않는다.
### 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
* 서버의 확장 가능성을 위해서. 클라이언트가 서버의 상태를 가지고 있다면, 서버의 확장이 어려워진다.
### HTTP Persistence Connection 란?
* keep-alive를 도입한 것.
### Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
* 매번 새로운 연결을 맺어야 하므로 성능이 안좋아질 여지가 있다. 하나의 요청으로 여러개의 요청을 처리하는 HTTP/2, 연결을 할 때 마다 생기는 시간을 절약하는 HTTP/3(UDP), keep-alive 도입 등을 통해 성능을 개선 할 수 있다.
### TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
* TCP keep-alive : 3-way handshake를 통해 연결된 세션을 없애지 않고 계속 사용하는 방식. 연결을 유지하기 원하는 쪽에서 keep-alive 패킷을 보내 연결을 끊지 않고 유지한다. 일정 시간동안 연결을 유지하고, 이후 닫음으로써 서버측의 사정으로 연결을 닫지 못할 때에 생기는 dead peer를 종료 할 수 있다.
* HTTP keep-alive : HTTP header에 keep-alive를 보내 keep-alive를 이용할지 말지 선택할 수 있다. 이를 통해 연결을 유지하여 매번 새롭게 연결을 맺는 방식의 속도를 개선 할 수 있다.
### 가상회선과 데이터그램과 관련해 stateless를 설명해주세요.
* 장애극복 관점
* 가상회선 : stateful, 통신 세션을 시작하기 전 경로 설정이 이루어지며 통신이 종료될 때 까지 유지됨. 경로 설정과 유지에 있어서 상태 정보를 필요로 함(TCP)
* 데이터그램 : stateless(soft) (UCP)

## 라우터 내의 포워딩 과정에 대해 설명해 주세요.
1. 네트워크 테이블을 검사하여 전달할 네트워크 주소를 찾아내고, 라우팅 테이블을 만든다.
2. 라우팅 테이블을 참조해 포워딩 테이블을 만들어, 가장 적합한 경로를 찾는다.
3. 목적지 IP 주소가 포함된 패킷을 라우터로 전송
### 목적지를 학습하는 방법, 브로드캐스트 컨트롤
1. 경로 지정: 경로 정보를 모아 라우팅테이블을 만든다.
  * 경로 정보 얻는 방법: 
    * 다이렉트 커넥티드: IP주소를 입력할 때 자연스럽게 인접 네트워크 정보를 자동으로 얻는 방법
    * 스태틱 라우팅: 관리자가 직접 정보를 입력하는 방법
    * 다이나믹 라우팅: 라우터끼리 정보를 교환하는 방법
2. 브로드캐스트 컨트롤: 라우터는 분명한 도착지 정보가 있을 때만 통신을 허락한다. 라우터로 들어온 패킷의 목적지 주소가 라우팅 테이블에 없으면 패킷을 버린다. 이러한 기능 덕분에 패킷이 다른 네트워크로 전달되지 않는다.

### 라우팅과 포워딩의 차이는 무엇인가요?
* 라우팅은 출발지에서 목적지까지의 최적의 경로를 생성하는것, 포워딩을 라우팅된 경로를 통해 패킷을 전송하는 것
### 라우팅 알고리즘에 대해 설명해 주세요.
* 관리자가 수동으로 라우팅 테이블을 설정하는 정적 라우팅
* 네트워크 상태의 변화에 자동으로 대응하는 동적 라우팅
  * dictance Vector : 인접 라우터와 거리 정보를 교환하여 최단 경로 계산
  * link state : 네트워크의 전체적인 상태를 파악하여 최단 경로 계산
  * path Vector : 경로의 속성 정보를 이용하여 라우팅 결정

## 로드밸런서가 무엇인가요?
* 로드밸런서는 네트워크 트래픽이나 서버에 가해지는 부하를 분산시키는 기술 또는 창치.
### L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
* L4 : osi 4계층에서 작동하며, 포트 번호를 기반으로 부하를 분산한다. L4레이어에서 작동하기에 더 빠른 속도를 가진다.
* L7 : osi 7계층에서 작동하며, URL이나 HTTP 헤더 기반으로 부하를 분산한다.(nginx) 그렇기에 L4에 비해 다양한 정보를 통해 로드밸런싱이 가능하다.
### 로드밸런서 알고리즘에 대해 설명해 주세요.
* 라운드 로빈 : 클라이언트로부터 받은 요청을 서버에 순서대로 할당한다. 서버의 성능이 동일하고 처리 시간이 짧은 애플리케이션은 요청이 균등하기에 이 방식을 사용한다.
* 가중 라운드 로빈 : 각각 다른 서버 성능에 따라 가중치를 주어 처리한다.
* 최소 연결 방식 : 연결 수가 가장 적은 서버를 동적으로 파악하여 연결을 한다.
### 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
* Health Checks : 각 서버들의 상태를 확인하는 기능. 서버가 응답하지 않거나 문제가 있다면 정상 서버에만 요청을 분산한다.
* Manual Removal : 관리자가 직접 제거할 수 있다.
### 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
* 도메인에 대해 여러 A레코드를 생성하여 각각 다른 서버의 IP주소를 가리키도록 하여 라운드로빈 방식을 통해 로드밸런싱을 할 수 있다.

## 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.
* IP주소는 네트워크 식별자, 호스트 식별자로 이루어져 있다. 이 때, ip에서 네트워크 식별자가 같다면 같은 네트워크 안에 있다는 뜻이고, 호스트 식별자는 각각의 컴퓨터를 구분하는 주소이다. IP주소와 서브넷마스크의 and연산을 네트워크 식별자를 알 수 있다. 라우터는(공유기 등)은 공인 IP와 사설 IP를 가지는데, 이 때 사설 IP가 게이트웨이역할을 한다.
* 게이트웨이 : 한 네트워크에서 다른 네트워크로 이동하기 위하여 거쳐야 하는 지점이다.
### 서브넷이란?
* 서브넷이란 네트워크 내의 작은 네트워크(sub networt)를 말한다. 이 서브넷을 통해 불필요한 라우터를 통과하지 않고 더 짧은 거리를 이동하여 대상에 도달할 수 있다. 
### IP주소의 각기 다른 부분의 의미
* IP주소의 앞부분은 주소가 속한 네트워크, 뒷부분은 네트워크 내의 장치이다.
* 클래스에 따라 앞부분 1~3개가 네트워크, 나머지가 장치가 된다.
### 내 인터넷은 어떤 클래스에 속하는지 확인하려면?
* 클래스 A : 첫 번째 마디 0~127, 공인은 10.x.x.x, 대규모 네트워크용
* 클래스 B : 첫 번째 마디 128~191, 공인은 172.16~21.x.x, 중규모 네트워크용
* 클래스 C : 첫 번째 마디 192, 공인은 192.168.0~255.x, 소규모 네트워크용
### NAT에 대해 설명해 주세요.
* Netword Adress Transration
* 한정된 IPv4 주소문제를 해결하기 위해 개발되었다. 장치의 수가 많아짐으로써 모든 장치에 고유한 IP를 줄 수 없게 되었다. 이를 위해 하나의 공인 IP를 여러 개의 사설 IP주소와 공유할 수 있도록 한다.
* 네트워크 장비가 NAT translation table을 통해 작동한다. local 네트워크는 host서버에 패킷을 보내고, NAT 라우터는 이 주소를 자신의 주소로 바꾸고, 이를 식별할 수 있는 포트 번호를 새로 부여한다. 서버는 해당 패킷을 받고, 라우터의 주소로 포트번호와 함께 응답 패킷을 보낸다. 이 패킷을 NAT 라우터가 NAT translation Table에서 포트 번호를 보고 특정해서 host에게 보낸다.
### 그렇다면 IP주소의 수가 거의 무한한 IPv6은 NAT를 지원하지 않을까요?
* 로컬 IP와 통신하는 등 보안상의 이유로 사용할 수도 있다.
### 포트포워딩이란?
* NAT의 응용으로, 패킷이 방화벽이나 라우터같은 네트워크 게이트를 지날 때 IP주소와 포트 번호의 결합의 통신 요청을 다른 포트로 넘겨주는 기법.
### 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
* 해당 IP주소의 네트워크 부분이 어디까지냐에 따라 표현한다. 일반적으로 4개의 8비트 옥텟을 사용하거나 이진수로 표현한다. 또는 연속된 1비트의 수로도 표현한다. `/24`와 `255.255.255.0`은 같다.
### 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
* 서브넷마스크는 앞쪽부터 1이 차있고, 1과 0이 연속적이어야한다. 그러므로 불가능하다. 

## 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.
* 두 개 이상의 프로세스가 하나의 통로를 사용해 통신 할 때, 이를 하나로 통합하는 것. 반대로 이렇게 온 복합 데이터를 원래대로 분리하는 과정.
* 네트워크에서는 전송(트랜스포트) 계층에서 제공한다.
### 멀티플렉싱과 디멀티플렉싱의 과정에 대해 설명해 주세요.
* 멀티플렉싱 : 여러 소켓의 데이터를 수집하여 헤더데이터와 함께 세그먼트로 캡슐화한다.
* 디멀티플렉싱 : 각 세그먼트의 헤더를 확인해서 원래의 데이터스트림으로 분리한다. 이 때 헤더의 stream id를 통해 신뢰성(기존의 순서)를 보장한다.
* 세그먼트는 헤더와 페이로드로 구성되며, 헤더에는 출발지와 목적지, 크기, 순서 등, 기존 패킷으로 분해하기 위한 정보가 포함되어있다. 페이로드에는 실제 데이터가 있다.

## XSS에 대해서 설명해 주세요.
* Cross site Scripting : 해킹 기술이며, 웹사이트에서 악성 스크립트를 주입하는 공격 방법. 주소 JS를 사용해서 공격한다.
* 사용자의 요청에 포함된 스크립트가 서버로부터 그대로 반사(Reflected)되어 응답메시지에 포함돼 브라우저에서 스크립트를 실행되는 공격기법인 Reflected XSS (1회성), 악성 스크립트를 서버에 저장시키는 Stored XSS, 브라우저가 html을 분석하여 생성할 때 DOM의 일부러 악성 스크립트를 전달하는 DOM Based XSS가 있다(이는 클라이언트에서 DOM을 이용해서 동적으로 페이지를 조작 할 때 발생한다). 
* 사용자의 입력에 대해 의심, 검증하는 작업을 통해 막을 수 있다. HTML의 태그나 자바스크립트에서 사용되는 특수문자들은 필터링 혹은 인코딩 할 수 있다. 혹은 이러한 기능을 제공하는 보안 라이브러리들을 쓸 수 있다.
### CSRF랑 XSS는 어떤 차이가 있나요?
* CSRF(Cross site Request Forgery) : 주로 서버측에서 발생, 사용자의 의도와 무관하게 공격자가 의도한 바를 서버에 전송하게 만든다.
  * 사용자 요청에 대한 `Referrer`헤더를 감지하는 방법을 통해 한다. 이 값이 'host`와 같은 경우 안전하다.
* XSS : 주로 클라이언트 측에서 발생, 브라우저에서 악성 스크립트가 실행되게 만드는 것에 초점을 맞춘다.
### XSS는 프론트엔드에서만 막을 수 있나요?
* HTML tag를 제거하는 등 저장시 입력값 검증을 통해서 서버측에서도 막을 수 있다.