# 네트워크
## TCP와 UDP
* OSI 4계층에서 사용하는 통신 프로토콜
### TCP
* 패킷 사이의 순서를 보장하고 연결 지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부 확인
* 연결형
* 3 way handshake(연결)
  1. SYN단계 : 클라이언트의 ISN을 담아 SYN을 보냄
  2. SYN+ACK 단계 : 서버는 클라이언트의 SYN 수신 후 서버의 ISN과 클라이언트의 ISN+1을 담아 SYN을 보냄
  3. ACK 단계 : 클라이언트는 서버의 ISN+1 값인 승인번호를 담아 ACK를 보냄
* 4 way handshake(연결 해제)
  1. 클라이언트가 FIN을 보내고 서버의 응답을 기다림
  2. 서버는 ACK를 보냄
  3. 일정 시간 후 서버는 FIN을 클라이언트에 보냄
  4. 클라이언트는 서버로 ACK를 보내고 연결해제
### UDP
* 신뢰성이 보장되지 않기에 데이터 손실 가능성이 있음
* 신뢰성 확인을 하지 않기에 TCP에 비해 용량이 가볍고 송신 속도가 빠름
* 비 연결형
## HTTP
* HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. 하이퍼텍스트(HyperText)는 인터넷 사용자가 필요한 정보의 자유로운 검색을 가능하도록 해주는 텍스트의 전개 방식이다. HTTP는 이러한 하이퍼텍스트 방식의 정보를 교환하기 위한 하나의 규칙이다.
### 특징
* 요청과 응답 두 가지 유형이 있음
* 헤더와 바디로 이루어짐
* 무상태성
  * 클라이언트와 서버 간에 상태 정보를 들고있지 않음
* 비연결성
  * 한번 통신 후 연결이 끊어짐
### HTTPS
* 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청
* SSL handshake
  1. Client Hello 
    * 브라우저가 사용하는 암호화 정보와 알고리즘을 보냄
  2. Server Hello
    * 사용 가능한 알고리즘 선택, SSL인증서(공개키와 서버의 신원정보를 포함) 클라이언트로 전달
  3. 서버 인증서 확인
  4. Premeter Secret
    * 대칭키 생성 후 서버로 전송
  5. Premeter Secret 복호화
  6. SSL handshake 종료 및 HTTPS 통신 시작

### HTTP 응답코드
* 1xx : 정보 응답
  * 100 Continue : 지금까지의 상태가 괜찮음
  * 101 Swiching Protocol : 클라이언트가 보낸 요청 헤더에 대한 응답에 들어가며 서버에서 프로토콜을 업데이트 할 때
  * 102 Processing : 처리중일 때
* 2xx : 성공
  * 200 OK : 성공적으로 처리
  * 201 Created : 새로운 리소스가 생성됨
  * 202 Accepted : 요청은 허용되었지만, 처리가 완료되지 않음
  * 204 No Content : 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없음
* 3xx : 리다이렉션
  * 300 Multiple Choices : 선택 항목이 여러개이다
  * 301 MovedPermanetly : 지정한 리소스가 새로운 URI로 이동하였다
  * 302 Found : 다른 위치 찾음
  * 303 See Other : 다른 위치 보기
  * 307 Temporary Rediect : 임시로 리다이렉션 요청이 필요하다
* 4xx : 클라이언트 에러
  * 400 Bad Request : 요청이 잘못되었다
  * 401 Unauthorized : 리소스에 대한 권한이 없음
  * 403 Fobidden : 지정한 리소스에 대한 요청이 금지되었다
  * 404 Not Fount : 지정한 리소스를 찾을 수 없다
* 5xx : 서버 에러
  * 500 Internal Server Error : 서버에 에러가 발생하였다
  * 501 Not Implemented : 해당 URI의 메서드에 서버에서 구현되지 않음
  * 502 Bad Gateway : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다
* 사용자가 임의로 http 응답코드를 만들어서 사용하는 경우, 서버와 클라이언트 양 측에서 해당 코드에 대한 정보가 있어야한다. 그렇지 않으면 클라이언트에서는 xx0코드로 처리된다.

### HTTP 메소드
* 주요 메소드
  * GET : 리소스 조회
  * POST : 요청 데이터 처리, 주로 등록에 사용
  * PUT : 리소스를 대체, 해당 리소스가 없다면 생성
  * PATCH : 리소스 부분 변경
  * DELETE : 리소스 삭제
* 기타 메소드 
  * HEAD : GET과 동일하지만 메시지부분을 제외하고 상태줄과 헤더만 반환
  * OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
  * CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
  * TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행
* HTTP 메서드의 멱등성
  * HTTP 메서드중 GET, PUT, DELETE 등은 여러번 수행되어도 결과가 같은 멱등성을 가진다

### Rest란?
* Representational State Transfer의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것
* 이러한 규칙을 지켜 만든 API를 Restful API라고 한다.
* HTTP URI를 통해 자원을 명시하고, Method를 통해 해당 자원에 대한 동작을 적용한다.
* 장점
  * 쉬운 사용성 : API의 의도를 쉽게 파악 가능
  * 클라이언트와 서버의 분리
  * 데이터의 명확한 표현
* 단점 
  * 메서드 형태가 제한적
  * 표준이 명확하지 않음

## 프록시 서버란?
* 클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 중간에 대신 전달해주는 서버
### 프록시서버 사용 이유
* 보안 : 서버의 IP를 숨기는 것이 가능
* 캐시 : 이전에 했던 요청들을 프록시서버에 캐싱해둘수 있다
### 포워드 프록시
* 클라이언트에서 요청을 할 때 직접 요청하는 것이 아닌 프록시서버를 거치는 방식이 포워드 프록시
* 캐싱, 보안을 위해 사용
### 리버스 프록시
* 서버에서 클라이언트에 직접 데이터를 전달하지 않고 프록시서버를 거치는 방식이 리버스 프록시
* 캐싱, 보안, 로드밸런싱
* nginx를 사용해 리버스 프록시 서버 사용 가능

### DNS서버란?
* 도메인 네임 시스템은 호스트의 도메인 네임을 네트워크 주소로 변환하거나, 그 반대의 역할을 수행하는 시스템이다.
* Local DNS(기지국 DNS) 서버란?
  * 인터넷을 사용하기 위해서는 IP를 할당해주는 통신사에 등록해야한다. 이후 컴퓨터가 LAN선을 통해 연결되면, 가입했던 통신사의 기지국 DNS서버가 등록되게 된다. 


## naver.com을 치면 일어나는 일
### 네트워크 흐름 측면에서
1. 사용자가 브라우저에 도메인 네임 `www.naver.com` 을 입력한다.
2. 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3. 페이지 URL 정보와 전달 받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이 과정에서 소켓과 포트가 사용되며, 소켓은 IP주소와 포트번호, 사용할 프로토콜(TCP)의 조합으로 네트워크 서비스를 사용하는데 필요한 엔드포인트이다. HTTP는 80, HTTPS는 443포트로 연결 요청을 보낸다.
4. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력 되어 사용자가 볼 수 있게 된다.

### DNS서버 에서
1. 브라우저가 캐시에서 `www.naver.com`에 대응되는 IP주소가 존재하는지 확인한다
  * 브라우저 자신이 저장하고 있는 캐시를 가장 먼저 탐색한다
  * 이후 os에 저장된 캐시를 탐색한다. (윈도우의 host 파일)
  * 라우터(공유기)에 저장되어 있는 캐시 정보를 탐색한다
  * local DNS서버의 캐시를 확인한다
2. local DNS서버에서 `www.naver.com`에 대응되는 IP주소 정보를 요청한다
3. Root DNS 서버는 .com으로 끝나는 도메인에 대한 DNS정보가 담긴 서버의 IP주소를 반환
4. 반환받은 주소를 통해 .com DNS서버로 다시 `www.naver.com`에 대한 IP주소 정보 요청
5. .com DNS서버는 `naver.com` 도메인에 대한 정보가 담긴 서버의 IP 주소 반환
6. `naver.com` DNS서버는 `www.naver.com` IP주소가 저장되어있어 해당 IP주소를 반환한다

# 네트워크 심화질문
## 쿠키와 세션의 차이에 대해 설명해주세요.
* 쿠키와 세션 :  HTTP는 상태를 저장하지 않기때문에, 상태를 저장하기 위해 사용한다.
* 쿠키 : 클라이언트에 키와 값으로 저장된다.
* 세션 : 쿠키를 기반으로 하지만, 쿠키로는 세션ID만을 저장하고 필요한 데이터는 서버에 저장한다. 서버 부하가 심하지만, 쿠키에 비해 보안이 강력하다.
### 세션방식의 로그인 방식에 대해 설명해주세요.
* 클라이언트에서 인증(로그인)이 이루어 졌을 때, 서버에서는 쿠키에 세션ID를 담아 클라이언트측에 보내면 로그인이 완료된다.
* 로그인 이후 해당 세션ID를 가지고 서버에 인가 요청을 한다. 그러면 사용자에 따른 응답을 한다.
### HTTP의 특성인 Stateless에 대해 설명해주세요.
* 서버는 클라이언트의 상태를 저장하지 않으며, 따라서 이전 요청과 다음 요청의 맥락이 이어지지 않는다. 그렇기에 이전 요청과 다음 요청의 맥락이 이어지지 않는다.
### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
* 세션은 어느정도 stateless 원칙을 위반하는 측면이 있다. 하지만 매번 모든 정보를 클라이언트에서 함께 요청하다보면, 더 많은 데이터가 소모된다. 그렇기에 꼭 필요한 경우에는 어느정도 상태 유지를 사용해야만 한다.
### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
* 서버 모두가 세션을 공유해야 하기 떄문에 세션 저장소를 두어 모든 서버에서 해당 저장소를 바라보게 하면된다. 오류를 대비해 백업용 세션 저장소까지 준비하면 좋다.

## HTTP 메서드에 대해 설명해주세요
* HTTP는 여러 가지 메서드를 정의하여 클라이언트가 서버에게 요청을 보내고 서버가 해당 요청에 응답하는 방식을 결정.
* GET : 리소스를 가져오기 위해 사용.
* POST : 새로운 데이터를 제출하기 위해 사용.
* PUT : 지정된 위치에 리소스를 저장하거나 업데이트하기 위해 사용.
* DELETE : 지정된 리소스를 삭제하기 위해 사용.
* PATCH : 리소스의 부분적인 업데이트를 위해 사용
* HEAD : GET과 유사하지만 헤더만을 반환.
* OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS에서 사용)
### HTTP Method의 멱등성에 대해 설명해 주세요.
* 몇 HTTP 메서드들은 여러번 실행되어도 같은 결과를 가진다. 이를 멱등성이라고 한다.
### GET과 POST의 차이는 무엇인가요?
* 용도로 따지면 GET은 리소스를 조회할 때, POST는 새로운 데이터를 제출할 때 사용한다. 또한 GET은 데이터를 URL의 쿼리 문자열에 포함하여 서버로 전송하며, POST는 본문에 포함하여 전송한다. 또한 GET요청은 캐싱을 통해 성능 향상을 노려볼 수 있으며, POST는 일반적으로 캐싱하는것이 의미가 없다.
### POST와 PUT, PATCH의 차이는 무엇인가요?
* 용도로는 생성과 수정이라는 차이를 가진다. 실제 동작에서는, POST는 특정 자원을 목적으로 하는 것이 아니므로, 새로운 데이터가 생성되며 멱등성을 가지지 않는다. 하지만 PUT과 PATCH는 특정 자원을 상대로 하므로, 만약 이전에 없던 데이터에 대해 PUT이나 PATCH 메서드를 사용하더라도 멱등성을 가진다.
### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
* 일반적으로 GET요청은 캐싱을 할 수 있다. 하지만 GET에 Body가 포함되면 캐싱이 어려워지거나 일관성이 깨질 수 있다. 몇몇 서버나 미들웨어는 Get요청의 Body를 처리하지 못할 수도 있으며, 또한 Restful 설계원칙에 맞지 않게 된다.

## HTTP에 대해 설명해주세요.
* Hyper Text Transfer Protocol로, 서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규약.
* HTML, TEXT, IMAGE, 음성, 영상, JSON등의 데이터를 전송할 수 있다.
* 클라이언트가 요청하면 서버가 응답한다. 
* 무상태성(stateless) : 클라이언트와 서버 사이에 상태를 유지하지 않는다.
* 비연결성(connectionless) : 클라이언트와 서버 사이에 연결을 지속하지 않는다.

### 공개키와 대칭키에 대해 설명해 주세요.
* 대칭키 : 키가 동일한 암호화 방식. 해당 키를 알아야만 문서를 복호화해 볼 수 있게된다. 수행시간이 짧지만, 안전한 키교환 방식이 요구된다.
* 공개키 : 대칭키의 키교환 문제를 해결하기 위해 등장한것이 공개키이다. 공개키로 암호화, 개인키로 복호화한다. 속도가 느린 단점이 있다.
### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
* 서버의 인증서를 통해 서버의 신원을 확인할 수 있고, 공개키를 통해 안전하게 대칭키를 공유할 수 있다.
### SSL과 TLS의 차이는 무엇인가요?
* 둘 모두 보안을 위한 프로토콜.
* SSL은 사실상 종료되었으며, TLS는 SSL에서 보다 더 안전한 암호화 알고리즘을 사용한다. (RC4 > AES) 또한 더욱 엄격한 인증서 검증 과정을 거친다.

## 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
* 소켓 통신 : TCP/IP 프로토콜을 이용하여 데이터를 송수신하는 연결부를 의미한다.
* 웹소켓 : HTTP 레이어에서 작동하며, 실시간 양방향 통신을 가능하게 한다.
### 소켓과 포트의 차이가 무엇인가요?
* 소켓 : 네트워크에서 두 대의 디바이스간의 데이터 송수신을 위한 통신 엔드포인트. 소켓을 열기 위해서는 호스트에 할당된 IP 주소, 포트넘버, 프로토콜이 필요하다.
* 포트 : 네트워크에서 특정 소프트웨어의 데이터를 전달하기 위한 통신 채널을 식별하는 번호. 호스트 내부적으로 프로세스가 할당받는 고유한 값이다.
### 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
* 하나의 프로세스는 같은 IP주소, 같은 프로토콜, 같은 포트넘버를 가지는 여러개의 소켓을 가질 수 있다.
  * ex : 하나의 서버가 여러개의 클라이언트와 통신하는 경우 
### 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
* 웹 서버는 일반적으로 동시에 열 수 있는 소켓의 수를 제한하고, 요청을 처리한 후에는 소켓을 종료하기에 무수히 많은 소켓이 생성되지는 않는다. 다만 서버의 성능이 무한하다면 소켓수에 대한 제한을 두지 않고 무수히 많은 사용자의 요청을 동시에 처리할 수 있을 것이다.

## HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
* HTTP/1.1
  * 연결 한 개당 하나의 요청을 처리하도록 설계됨.
    * 요청과 응답이 순차적으로 이루어짐. 동시에 리소스를 주고 받는것이 불가능, 다수의 리소스를 처리하려면 대기시간이 길어짐
  * HOL(Head Of Line) Blocking이 발생할 수 있다.
    * 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * RTT(Rount Trip Time) : 매번 요청별로 연결을 만들게 되고, 3-way handshake가 반복적으로 일어나며 불필요한 RTT의 증가와 네트워크 지연을 초래
  * 무거운 Header 구조 : 매 요청마다 중복된 헤더 값을 전송하며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송
* HTTP/2
  * Multiplexed Streams : 연결 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며 응답은 순서에 상관 없이 스트림으로 받는다.
  * Stream Prioritization : 리소스간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결 할 수 있다.
  * Server Push : 클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다.
  * Header Compression : 헤더의 중복이 발생할 경우 Static/Dynamic Header Talbe 개념을 이용해 중복을 검출하고, 중복되지 않은 index값 + Header 정보를 허프만 인코딩 방식으로 데이터를 전송한다.
### HOL Blocking 에 대해 설명해 주세요.
* 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에의해 지연될 때 발생하는 성능 저하
  * HTTP/1.1에서는 연결 한개당 하나의 요청만을 처리하기 때문에 발생
  * HTTP/2에서는 패킷이 손실되어 재전송되는 동안, 뒤에 오는 패킷들은 대기상태가 되어 발생(순서를 보장해야하기 때문에)
### HTTP/3.0의 주요 특징에 대해 설명해 주세요.
* 반복된 Handshake 과정에서 발생하는 지연시간과 재전송으로 인한 HOL Blocking을 해결하기 위해 TCP 프로토콜 대신 QUIC 프로토콜을 사용한다.
 * TCP의 구조적 한계
  * TCP는 신뢰성을 위해 패킷을 순서대로 처리해야함, 이로 인해 패킷이 중간에 유실되거나 수신측의 패킷 파싱 속도가 느리다면 병목이 발생한다
  * UDP는 패킷의 목적지만 정해진다면 중간 경로를 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요 없음.
* QUIC 프로토콜 : Quick UDP Internet Conntections, 즉 UDP기반의 프로토콜
  * 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서대로 재조립할 수 있게 한다.
  * 또한 checksum을 사용해 패킷의 무결성을 보장한다.

## TCP와 UDP의 차이에 대해 설명해 주세요.
* TCP : 연결형 서비스, 흐름제어와 혼잡제어를 세종하며 패킷 손실 방지. 데이터의 순서와 신뢰성을 보장
* UDP : 비연결형 서비스, 데이터의 순서와 신뢰성을 보장하지 않음. 헤더의 크기가 작아 처리가 빠르고, 실시간 서비스에 적합하다. DNS조회, 스트리밍 등에 주로 사용된다.
### Checksum이 무엇인가요?
* Checksum : 송신된 자료의 무결성을 보호하는 방법.
### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
* 둘 다 체크섬을 수행 할 수 있지만, TCP는 필수이고 UDP는 선택적이다.
### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
* 데이터의 무결성을 확인 할 수 있지만, 오류를 정정할수는 없다.
### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
* 각 데이터 패킷에 순서 번호를 부여하여 수신자가 패킷을 올바른 순서로 재조립할 수 있게 하며, 체크섬을 사용하여 오류가 있는지 확인하고 일치하지 않으면 재전송을 요청한다.
### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
* AIMD : 각 연결마다 윈도우 크기를 설정한다. 성공적으로 수신하면 1 증가시키고, 실패하면 절반으로 감소한다.
* Slow Start : 윈도우 사이즈를 2배씩 증가시키고, 혼잡현상이 한번 발생하면 1씩 증가시킨다.
### 왜 HTTP는 TCP를 사용하나요?
* TCP의 신뢰성의 때문에. 
### 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
* HOL 블로킹을 해결하기 위해 UDP를 사용한다. 패킷이 순서대로 도착해야함에 의한 시간 소요와 연결, 연결 해제를 위한 시간 소요를 줄이기 위해 사용한다. UDP에서 QUIC프로토콜을 사용함으로써 신뢰성을 확보한다.
### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
* Alt-Svc 헤더 응답이 있어야한다
### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
* QUIC 프로토콜을 사용하기 위해서는 클라이언트에서 더 많은 처리를 필요로 하므로 필요 하드웨어 사양이 높아지게 된다. 그렇기에 하드웨어 사양과 요구 속도, 신뢰성 여부 등을 파악해 선택하겠다.