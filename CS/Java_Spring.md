# Java_Spring

## JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
* Java Virtual Machine으로, Java의 바이트코드를 OS환경과 독립적으로 실행시켜주는 가상머신이다.
### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
* JVM위에서 돌아가는 Jython, Kotlin, Scala등이 있다. 이런 언어들도 코드를 바이트코드로 변환함으로써, JVM위에서 실행될 수 있다.
### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
* 코드를 OS독립적으로 작성 할 수 있고, 실행 할 수 있다. 하지만 가상머신이라는 환경이 필요한 만큼, 각 OS에 최적화된 성능이 아닐 수도 있는 점이 단점이다.
### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
* JVM은 운영 체제 위에서 별도로 실행되는 프로그램이다. 내부에서 쓰레드를 사용하여 여러 작업을 처리하기에, 단일 프로세스-스레드 관계라고 보는것이 적절하다.

## final 키워드를 사용하면, 어떤 이점이 있나요?
* 특정한 값에 대해 불변성을 보장 할 수 있고, 멀티 스레드 환경에서 한 번만 할당됨으로써 스레드 안정성을 향상시킨다. 상속을 받는 등의 경우에도 불변성이 보장된다.
### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
* 컴파일시에 final변수는 변수를 사용하는 위치에 직접 그 값을 삽입할 수 있다.
* 메소드나 클래스 역시 오버라이드, 상속이 불가능하기에 추가적인 최적화가 이루어진다.

## 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
* 인터페이스는 모든 메소드가 추상메소드이다. 다중 상속을 지원하며, 상속받은 클래스는 인터페이스의 모든 추상 메소드를 구현해야 한다.
* 추상 클래스는 하나 이상의 메소드가 추상메소드이다. 이미 구현된 메소드가 있을 수 있고, 한 번에 하나의 추상 클래스만을 상속 가능하다.
### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
* 인터페이스는 모든 메소드가 추상메소드이기에, 인터페이스끼리 중복되는 메소드가 있더라도 문제가 없다. 하지만 클래스는 중복되는 메서드가 있는 경우, 어떤 메서드를 우선적으로 사용해야 할 지를 판단 할 수 없기에 2개 이상은 상속 받을 수 없다.

## 리플렉션에 대해 설명해 주세요.
* 런타임 단계에서 구체적으로 알지 못하는 객체의 클래스에 접근 할 수있도록 해주는 API. 런타인 단계에서 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법이다. 클래스가 로드되면 method area에 저장되는데, 이러한 정보를 자바 리플렉션 API에서 접근한다. DI나 어노테이션 등에서도 리플렉션을 통해 객체의 정보를 가져온다. 이렇게 동적으로 클래스의 정보를 얻음으로써 유연성과 확장성이 증가하지만, 캡슐화를 저해할 우려가 있고 성능이 느려 질 수 있다.
### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
* 실제로 pivate가 붙은 클래스 등에도 접근 할 수 있기 때문에 보안에문제가 생길 수도 있다. 이를 Java의 security manager 에서 reflectionPermissoin을 통해 제어 할 수 있다.
### 리플렉션을 언제 활용할 수 있을까요?
* 의존성 주입, 컨트롤러 처리 등에 사용된다.

## static class와 static method를 비교해 주세요.
* static으로 선언된 class는 외부 클래스의 인스턴스 생성 없이 내부 static 클래스의 인스턴스를 생성 할 수 있다.
* static method: 클래스의 인스턴스 없이 호출 할 수 있다. 인스턴스 변수에 직접 접근 할 수 없고, static 변수만 접근할 수 있다.
### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
* 클래스가 로드 될 때 한 번만 생성되므로, 메모리 사용을 줄일 수 있다. 전역으로 어디서든 접근 할 수 있다는 점에서도 장점이 있다. 하지만 공유 상태를 너무 많이 사용하면 객체 간의 결합도가 높아지고, 멀티스레드 환경에서 문제가 생기며, 테스트하기 힘들어지는 문제가 생길 수 있다.
### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
* static 키워드를 가진 변수들은 클래스 단위로 관리되어 method영억에 로드한다.

## Java의 Exception에 대해 설명해 주세요.
* 프로그램 실행 중 발생하는 예외를 적절하게 처리 할 수 있도록 하는 것.
### 예외처리를 하는 세 방법에 대해 설명해 주세요.
* try-catch를 사용하고 finally를 사용하거나, throws를 통해 해당 메소드에서 처리 하지 않고 호출 한 곳으로 예외를 던질 수 있다. 혹은 사용자가 throw new Excepthion을 통해 강제로 예외를 발생시킬 수 있다.
### CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
* CheckedException: 컴파일시점에 반드시 처리해야 하는 예외. IOException, SQLException 등이 있다.
* UnCheckedException: 컴파일시점에 처리르 강제하지 않는 예외. 런타임 시점에서 발생하며, NullPointerException, 어레이 인덱스 초과 익셉션 등이 있다.
### 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
* 예외가 발생하면 발생한 예외를 처리 할 수 있는 exception handler가 포함된 메서드를 찾기 위해 call stack을 검색하게 된다. 메서드가 호출된 역순으로 탐색하기에 성능이 저하 될 수 있다. 예외를 과도하게 세분화하기보다, 다른 응답으로 단순하게 처리 할 수 있다.

## Synchronized 키워드에 대해 설명해 주세요.
* 자바에서 멀티 스레딩 환경에서의 동기화를 위해 사용하는 키워드이다. 이 키워드를 사용하면 특정 코드 블럭이나 메소드에 대한 동시 접근을 제어 할 수 있다. Object 객체에 있는 모니터 락을 활용하여 동기화를 구현한다.
### Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
* 메서드에 적용되는 경우, 해당 메소드를 동시에 실행할 수 있는 스레드가 단 하나뿐임을 의미한다. 코드 블럭에 적용되는 경우, 특정 객체에 락을 걸 수 있다.
### 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
* 복잡한 동기화 필요없이 객체에 락을 걸 수 있지만, 해당 메서드나 코드블럭에 단 하나의 스레드만 접근 할 수 있어 병렬처리를 제한 하는 등 성능 저하가 초래될 수 있다.
### Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
* Concurrent Collections를 사용하면, 객체의 일부에만 락이 걸리기에 성능이 더 우수할 수 있다. 혹은 Lock 인터페이스를 사용해 세밀하게 락을 제어할 수 있다.
### Thread Local에 대해 설명해 주세요.
* 쓰레드가 자신반의 지역 변수를 사용할 수 있게 해주는 클래스이다. 이를 통해 동기화 없이 thread safe를 보장할 수 있게 해준다. 하지만 가비지 컬렉션의 대상이 되지 않으므로 주의해서 사용해야한다.

## Java Stream에 대해 설명해 주세요.
* 반복문이나 반복자를 사용해 매번 새로운 코드를 작성해야 하는 점을 해결하기 위해, 컬렉션의 요소를 고수준에서 추상화하여 표현하고 이 요소들에 대해 선언적으로 처리할 수 있게 해주는 기능.
### Stream과 for ~ loop의 성능 차이를 비교해 주세요
* for loop는 기본적인 반복 메커니즘을 사용하기에 오버헤드가 없어 단순한 메커니즘에서는 더 빠를 수 있고, 제어의 유연성이 있다. 특히 primitive타입에 대한 연산에서 직접참조 등에 대한 최적화가 잘 되어있고 더 빠르다.
* List에선 어차피 간접참조를 하므로 성능이 비슷하다. 하지만 stream은 Stream 객체 생성 등에 의해 조금 더 느리다.
### Stream은 병렬처리 할 수 있나요?
* parallelStream(), parallel()을 사용하면 ForkJoin방식을 사용하여 작업을 분할해 병렬적으로 처리하게된다. 하지만 병렬처리 과정 자체에서 오버헤드가 발생하기에 신중하게 선택해야한다.

## Java의 GC에 대해 설명해 주세요.
* 메모리의 할당과 해제를 직접 하지 않고, 프로그램 수준에서 관리해주는 것을 가바지 컬렉터라고 한다. Java의 GC는 힙메모리를 관리하며, 데이터의 생성 시기에 따라 old 영억와 new영억으로 나누어 더욱 효율적으로 관리한다. mark and swip 알고리즘을 사용하며, 참조된 객체를 마킹하고, 그 외의 객체를 정리한다. 이후 오래 살아남았다면 앞으로도 살아남을 확률이 높다고 판단하고, old영역으로 객체를 옮겨간다.
### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
* 언제 수행되는지 정확히 알 수 없고, 수행을 반드시 보장하지도 않기 때문이다.
### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
* null이 되면 더 이상 객체를 참조하지 않는다는 의미고, 이로 이제 해당 변수는 가비지 컬렉션의 대상이 되지 않는다.

## equals()와 hashcode()에 대해 설명해 주세요.
* equals는 객체가 같음을 어떻게 보장할 것인지에 대한 메서드이다. hashcode는 해당 객체가 해싱될 때, 어떤 값들에 의해 해싱된 값이 나올지에 대한 메서드이다.
* 이 둘을 함께 정의해야 하는 이유는, equals만 재정의한다면 hash관련 객체에 해당 객체를 넣을 경우, 같은 값을 가져야 함에도 그렇지 않게 처리 될 수도 있기 때문이다.
### 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
* 우선 equals에 대해 같은 값을 가지는 객체라면 해싱된 값도 같아야 한다. 그러므로 equals에 사용된 모든 필드를 동일하게 사용해야 할 것이다. 또한 해싱함수가 너무 복잡하지 않게 하고, 분산이 잘 되게 설계하면 좋을 것 같다.
### 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
* 어떤 필드들을 기준으로 객체의 같음을 판단할지에 따라 equals를 정의하는 기준이 달라진다. 이에 따라 필드별 대소를 판단해야하고, 필드별로 어떤 필드가 객체의 순서에 우선순위가 큰지 또한 잘 판단해야한다.

## IoC와 DI에 대해 설명해 주세요.
* IoC는 제어의 역전으로, 프로그램의 실행 흐름을 사용자가 정하는 것이 아닌 프레임워크가 정해놓은 실행 흐름을 결정하고, 필요한 시점에 개발자가 작성한 코드를 실행하는 것이다.
* DI는 IoC의 한 형태로, 컴포넌트간의 의존성을 컴포넌트 내부가 아닌 외부에서 주입하여 컴포넌트간의 결합도를 낮출 수 있다.
### 후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
* 그렇더라도 Bean으로 등록하면, 스프링 컨테이너가 클래스의 인스턴스 관리를 해주며 의존성 주입 등을 쉽게 할 수 있다. 또한 AOP의 지원, 라이플사이클 관리 등에도 훨씬 유용하다.
### Spring의 Bean 생성 주기에 대해 설명해 주세요.
* 설정파일에서 Bean 정의를 읽고, 스프링 컨테이너가 Bean 인스턴스를 생성한다. 이후 Bean간의 의존성에 따라 의존성을 주입한다. 이후 초기화 콜백 메서드가 호출되고, 사용 된후 소멸 전 콜백 메소드가 호출되고 스프링이 종료된다.

## Spring의 실행 과정에 대해 설명해주세요.
* 스프링이 실행되면 Bean 정의를 로드하고, 애플리케이션 컨텍스트를 생성하며 Bean간의 의존성을 분석합니다. 이후 스프링 컨테이너가 Bean 사이의 의존성을 기반으로 의존성을 주입합니다. 모든 Bean이 생성되고 의존성이 주입되면, 애플리케이션이 준비됩니다. 이후 Tomcat과 같은 서버가 실행된다.

## AOP에 대해 설명해 주세요.
* 관점 지향 프로그래밍. 클래스간 공통의 기능을 구현할 때, 중복 코드의 발생이 발생 할 수 있는 부분을 공통의 관심사로 모듈화하는 것. 이를 통해 로깅, 보안, 트랜잭션 관리 등과 같은 기능이 여러 클래스에 걸쳐 필요 할 때, 이 공통된 관심사를 분리하여 관리 할 수 있다. 
### @Aspect는 어떻게 동작하나요?
* @Aspect를 사용하면 해당 클래스가 aspect 빈으로 등록된다. 이후 이를 통해 어드바이저를 생성한다.

## Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
* Interceptor: 스프링에서 DispatcherServlet이 컨트롤러를 호출하기 전, 후에 특정 작업을 수행 할 수 있도록 하는 것.
* Servlet Filter: DispatcherServlet에 도달하기 전의 전체 요청에 대해 적용되어 Spring Context 외부의 요청에도 적용될 수 있다.
* 이 둘은 모두 요청에 대해 전처리와 후처리를 담당한다.
### 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
* 스프링 인터셉터는 스프링 컨텍스트 안에서 적용된다. 스프링의 예외처리를 위해서는 인터셉터를 사용하고, Request, Response객체를 조작해야하는 등 스프링과 분리되어야 하는 경우에는 필터를 사용하는 것이 좋다.

## DispatcherServlet 의 역할에 대해 설명해 주세요.
* HTTP프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러의 역할을 한다. 이로 인해 공통 작업에 대한 처리를 편리하게 할 수 있다.
### 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
* 멀티 스레드를 통해 여러 요청을 한번에 받을 수 있다. 그렇기에 thread safe를 고려해 애플리케이션을 설계해야한다.
### 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?
* HanddleMapping을 조회하여 알 수 있다. URL과 HTTP 메서드에 매칭되는 Controller를 찾는다.

## JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
* SQL 쿼리를 작성하는 코드의 반복을 줄이고, 관계형DB와 객체지향 패러다임 불일치를 해결하여 객체지향적인 개발을 위해 사용한다.
### 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
* 영속성은 Java객체와 데이터베이스 테이블간의 매핑을 관리하고, 객체 상태를 데이터베이스에 반영한다. 영속성 컨텍스트는 엔티티를 메모리 내부에 캐시하는 역할을 하여 동일한 엔티티에 대한 조회가 발생할 경우 캐싱 효과를 낼 수 있고, 지연로딩과 즉시로딩의 사용으로 성능을 향상시킬 수 있다. 반복조회에서는 성능이 좋을 수 있으나, 최적화가 필요한 복잡한 쿼리의 경우 직접 쿼리를 작성하는 것이 나을 수 있다.
### N + 1 문제에 대해 설명해 주세요.
* 엔티티를 조회할 때, 의도하지 않은 N번의 쿼리가 추가로 발생하는 현상.
* Fetch Join을 통해 해결 할 수 있지만, JPA가 제공하는 페이징사용시에 문제가 생길 수 있고, 쿼리를 직접 작성해야 하는 번거로움이 있으며 둘 이상을 Fetch Join을 할 수 없는 문제 등이 있다.

## @Transactional 은 어떤 기능을 하나요?
* 해당 메서드에서 실행되는 쿼리들이 한 트랜잭션으로 묶이게 된다.
### @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
* 읽기작업과 쓰기작업에서 사용되는 데이터베이스에서의 락 수준도 달라 질 수 있기때문에 도움이 된다. 또한 명시적으로도 읽기만 하는 쿼리라는 것을 알림으로써 코드의 가독성에도 도움이 된다.
### 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
* 읽기만 하는 경우에도 트랜잭션을 걸게되면 동일한 스냅샷 내에서 읽기가 이루어지기에, 여러 번의 읽기 작업이 이루어지는 메서드에서는 충분히 필요 할 수도 있다.

## Java 에서 Annotation 은 어떤 기능을 하나요?
* 컴파일러에게 코드를 어떻게 처리할지 알리는 역할을 한다.
### 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?
* Spring에서 lombok은 여러 메서드들을 컴파일 시점에서 생성해주고, 어노테이션을 통해 스프링 컨테이너가 의존성을 주입하는 등의 기능을 할 수 있다.
### Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?
* 롬복에서 제공하는 여러 개의 어노테이션을 합친 효과를 내는데, 상황에 따라 걸어야 하는 어노테이션들이 다르기 때문에 적합하지 않을 수도 있다.

## Tomcat이 정확히 어떤 역할을 하는 도구인가요?
* 주로 웹 어플리케이션 서버로 사용된다. 웹 서버와 통신, Servlet 컨테이너 제공, 웹 어플리케이션 생명주기 관리 등을 맡는다.