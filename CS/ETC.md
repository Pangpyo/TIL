# 개발상식, 기타

## 가상화가 무엇이고, 이것이 가상머신과 어떠한 차이가 있는지 설명해 주세요.
* 가상화란 물리적인 컴퓨터 자원을 여러 개의 가상 단위로 분할하여 사용할 수 있는 기술.
* 가상머신이란 가상화를 통해 생성된 가상의 컴퓨팅 환경으로, 각각의 운영체제를 가진다.
### 그렇다면 Docker는 둘 중 어디에 속하나요? 왜 사람들이 Docker를 많이 채택할까요?
* 도커는 가상머신과 유사하지만, 각각의 운영체제를 가지지는 않는다. 다만 가상 컨테이너를 통해 실행환경을 분리하고, 호스트의 운영 체제 커널을 공유한다.
* 도커는 가상머신에 비해 자원을 절약 할 수 있고, 더 빠른 속도를 가진다. 또한 이식성과 확정성 측면에서 유리하다.
### 하나의 Host OS에서 돌아간다면 충분히 한 컨테이너가 다른 컨테이너에 간섭할 수 있는 위험이 있지 않을까요? 이를 어떻게 방어할 수 있을까요?
* 네임스페이스를 통해 격리되도록 한다.
  * 네임스페이스는 컨테이너가 자신만의 네트워크 인터페이스, 파일 시스템 마운트, 프로세스 ID(PID) 목록 등을 가질 수 있게 해준다. 이를 통해 컨테이너가 호스트나 다른 컨테이너와 격리되어 독립적으로 실행될 수 있도록 한다.
### Docker 위에 Docker를 올릴 순 없을까요?
* 가능하다. docker-in-docker라고도 하며 도커는 이에 대한 공식 이미지를 제공하기도 한다.

## CI/CD 를 사용해 본 경험이 있나요? 있다면 간단하게 설명해 주세요.
* 젠킨스를 사용해 CI/CD를 구축하였습니다. git에서 특정 브랜치에 푸쉬나 머지 이벤트가 발생하면, 젠킨스에서 웹훅을 통해 이를 감지하여 해당 브랜치의 내용을 aws서버상에 가져오게 됩니다. 이를 통해 지속적 통합(CI)가 이루어집니다.
* 이후 파이프라인에 따라 CD도 진행하게 됩니다. 통합된 코드와 파일들을 빌드하고, 도커 이미지로 만들어 새로운 컨테이너를 배포하게 됩니다.
* fe, be를 한 서버에서 컨테이너를 통해 구축하였고, 서로 다른 컨테이너에 대한 관리를 docker compose를 통해 하였습니다.
### 도커 사용한 이유?
* 윈도우에서 사용했던 이미지를 그대로 도커를 통해 사용할 수 있기에, 테스트에 용이했다. 또한 파이썬 서버와 자바 서버를 모두 하나의 aws서버에서 구축 한 적이 있는데, Java서버는 17버전을 사용했었고, 파이썬 서버에서 사용했던 라이브러리중 하나가 jdk8을 요구했기에 이런 충돌 문제도 도커를 통해 해결 할 수 있었다.

## static 키워드는 어떤 의미를 갖나요? (본인이 사용하는 언어에서 없다면 패스...)
* Java를 예를 들어 설명하겠습니다.
* static으로 크게 변수와 메서드를 생성할 수 있는데, 변수의 경우에는 어떤 클래스의 인스턴스들이 공통적으로 사용해야 할 때 사용합니다. static 메서드는 인스턴스를 생성하지 않고 호출 할 수 있는 메서드입니다.(클래스로 만들어짐)
### 컴파일 할 때, static 키워드가 붙은 변수, 함수는 어떻게 처리되나요?
* 프로그램이 시작할 때 JVM의 static영역에 할당되어, 프로그램이 종료될 때 까지 유지된다.
### Java에서 static과 static final은 어떤 차이를 갖나요? final과 static final은요?
* static은 정적으로, 모든 인스턴스에서 접근 할 수 있다. 하지만 이는 변경 가능하다. static final은 static과 마찬가지로 프로그램 실행시 생성되지만, 이 값은 다른 인스턴스가 변경 불가능하다. final은 모든 인스턴스에서 직접 접근할 수 는 없고, 해당 클래스의 인스턴스를 생성 후, 그 값으로 접근해야한다.

## 객체지향 프로그래밍이 무엇인가요?
* 프로그램을 객체의 집합으로 표현하고, 데이터를 객체로 추상화하고 객체의 데이터와 메소드를 하나로 묶어 프로그램을 구성하는 프로그래밍 패러다임이다. 추상화, 캡슐화, 상속, 다형성의 핵심 특징을 가진다.
### SOLID 원칙에 대해 설명해 주세요.
* Single Responsiblily Principle(단일 책임 원칙): 한 클래스는 하나의 책임만 가져야한다.
* Open_Closed Principle(개방폐쇄원칙): 확장에는 열려있고, 변경에는 닫혀있어야한다.
* Liskov Substiuution Principle(리스코프 치환 원칙): 프로그램에서 부모 클래스의 인스턴스 대신 자식 클래스를 사용 할 수 있어야한다. 자식클래스는 부모 클래스의 모든 것을 가지고 있어, 부모클래스를 대체 할 수 있어야 한다는 뜻이다.
* Interface Segregation Principle(인터페이스 분리 원칙): 하나의 일반적인 인터페이스보다, 여러개의 구체화된 인터페이스를 만들어야한다.
* Dependency Inversion Principle(의존성 역전 원칙): 고수준의 모듈은 저수준 모듈의 구현에 의존되어서는 안된다. 객체가 어떤 클래스를 참조하여 사용 할 때, 변화하기 쉬운것에 의존하지 않고, 추상화된 상위 클래스나 인터페이스를 참조해야한다.
### 다형성이 무엇인지 설명하고, 동적 다형성과 정적 다형성이 무엇인지 설명해 주세요.
* 같은 이름의 메서드같은 것들이 다른 클래스에 대해 다른 동작을 하도록 하는 것. 동적다형성은 런타임에 결정되며 오버라이딩이 있고, 정적 다형성은 컴파일에 결정되며 오버로딩이 있다.
### 오버로딩과 오버라이딩의 차이에 대해 설명해 주세요.
* 오버로딩은 하나의 클래스 내에서 메서드가 들어오는 변수에 따라 다른 동작을 하게 하는 것이고, 오버라이딩은 자식이 클래스나 인터페이스를 상속 받았을 때, 자식클래스에 맞게 다른 동작을 하도록 하는 것이다.
### 클래스가 있는 언어는 반드시 객체지향 언어라고 할 수 있을까요? 그 반대는 성립하나요?
* 클래스가 있더라도 객체지향의 특징인 추상화, 상속, 캡슐화, 다형성의 특징을 가지지 않고, SOLID 원칙을 지켜지지 않는다면 객체지향 언어라고 할 수 없다. 또한 클래스가 없더라도 멤버변수와 메서드를 객체로 묶고, 객체지향의 특징과 원칙을 지켰다면 객체지향의 특징을 가진 언어라고 할 수 있다.

## 프레임워크와 라이브러리의 차이에 대해 설명해주세요.
* 둘 모두 연관된 기능이나 api등을 묶어서 사용 할 수 있도록 해놓은 집합이다. 가장 큰 차이는, 라이브러리는 사용자가 큰 흐름을 제어 할 수 있지만 프레임워크는 프레임워크가 전체적인 흐름을 관리한다.

## Call By Value와 Call By Reference의 차이를 본인의 언어를 기반으로 설명해 주세요.
* 자바를 기준으로 설명하면, 자바는 Call By Value로 동작합니다. 객체를 다룰 때 변수는 주소값을 가지고 있으므로, 마치 Call By Reference라고 생각할 수도 있지만 사실 그렇지 않습니다. 자바의 모든 변수는 값을 가지고 있으며, 이게 primitive type일수도 있고, 주소값일수도 있는 것입니다. 사용자가 직접 주소를 관리 할 수는 없기에 Call By Reference라고 할 수는 없습니다.

## MVC 패턴이 무엇인가요?
* Model, View, Controller로 나누어서 프로그램의 제어 흐름을 관리하는 패턴입니다. 여기서 Model은 데이터를 저장하는 역할을 하며, Controller는 View에서 온 요청을 받아 Model과 View를 업데이트합니다. View는 사용자의 입력을 받는 역할을 합니다.

## 디자인 패턴이 무엇인지 설명해주고, 대표적인 디자인 패턴에 대해 설명해 주세요.
* 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 일종의 솔루션 같은 것.
* 싱글턴 패턴: 클래스의 인스턴스가 하나만 생성되도록 보장하는 패턴.
### Singleton의 장단점에 대해 설명해 주세요.
* 인스턴스가 하나만 있는 것을 보장함으로써 메모리 낭비를 방지할 수 있다. 또한 데이터의 일관성을 보장 할 수 있다. 하지만 이런 하나의 인스턴스에 의존하므로 결합도가 높아지고, 멀티 스레드 환경에서 동기화 문제가 생길 수 있다.
### Singleton이 하나의 객체를 생성한다는 것을 어떻게 보장할 수 있을까요?
* static의 사용을 통해 하나의 객체를 생성하는 것을 보장하고, 이 객체가 변경되지 않도록 final을 사용하고, 외부에서 생성자를 통해 객체를 생성할 수 없도록 private를 붙일 수 있다. 혹은 의존성 주입을 통해 싱글턴의 결합도가 높아지는 점을 해결 할 수 있다.

## GC에 대해 설명해 주세요.
* 메모리의 할당과 해제를 직접 하지 않고, 프로그램 수준에서 관리해주는 것을 가바지 컬렉터라고 한다.
### 본인이 사용하는 언어에서는 GC를 어떻게 구현했나요?
* 자바에서는 JVM에 관리하며, 힙 영역의 더 이상 참조되지 않는 객체를 자동으로 식별하고 제거한다. 이 때, Mark and Sweep을 사용하여 구현되어있다. 이 때, 참조하고 있는 객체를 마킹하고, 마킹되지 않은 객체들을 제거한다. 이 때, 살아남은 시간에 따라 저장 영역이 바뀌어 갈 수 있다.(young, old)
### GC의 장단점에 대해 설명해 주세요.
* 메모리를 관리해주어 개발자의 부담이 줄어들지만, 이 GC가 언제 실행될지 사용자가 예측하기 힘드며, GC의 실행동안 실행이 잠시 멈추는 문제가 생긴다.

## 32비트와 64비트의 차이는 무엇인가요?
* 메모리 주소 공간이 최대 2의32승이냐, 2의 64승이냐의 차이이다.
### 32비트에서 가용한 메모리의 크기는 최대 4GB라고 하는데, 왜 그런걸까요?
* 2의 32승이 4GB이기 때문에
### 포트번호가 최대 65526인 이유는?
* 포트번호가 16비트로 표현되기 때문이다
## 인증과 인가의 차이에 대해 설명해 주세요.
* 인증: 사용자의 신원을 확인하는 과정.
* 인가: 인증된 사용자가 특정 작업을 수행 할 수 있는지 확인하는 과정.
### OAuth가 무엇인지 설명하고, 이것은 인증인지 인가인지에 대해 설명해 주세요.
* 다양한 플랫폼에서 인증을 가능하게 하고, 해당 서비스에서 인가를 관리해주는 것. 인증과 인가를 포함한다. 


## JWT 인증 방식이 무엇인가요?
* Jason Web Token, 사용자 인증을 위해 토큰을 통해 사용자의 신원을 확인하고, 자원에 대한 접근을 제어하는 방법이다. Stateless하다. Header에는 토큰의 유형과 해싱 알고리즘을, Payload에는 사용자에 대한 클레임(ID, 유효기간)을 포함하고, Signature에는 Header와 Payload를 BASE64로 인코딩하여, 해싱한 값을 다시 BASE64로 인코딩하여 만들어진다. 이는 유효성 검사를 위해 사용된다.
### 만약 Access Token이 탈취되면, 어떻게 대응할 수 있을까요?
* Access Token이 탈취되면 직접적으로 이를 막을 수 있는 방법은 없다. 대신 Access Token에 유효기간을 두어 이를 탈취하더라도 유효기간 이후 사용 할 수 없게 할 수 있다.
### 반대로 Refresh Token이 탈취되면, 어떻게 대응해야 할까요?
* RefreshToken은 Access Token요청 시 클라이언트 계정 정보를 함께 포함해야하기에, 이만 탈취당했을 때는 문제가 없다. 동시에 탈취되는 경우, IP를 확인하여 비정상적인 활동을 감지하고 액세스토큰과 리프레쉬 토큰을 만료시키고 새로 생성하거나, 사용자에게 알리는 등의 조치를 취할 수 있다.

## 암호화 알고리즘에 대해 설명해 주세요.
* 중요한 정보를 제3자가 읽을 수 없는 형태로 변환하여 정보의 안정성을 보장하는 기술.
### AES
* 대칭키 암호화 방식으로, 바이트 값으 대체를 위한 S-Box라는 대칭표를 가지고 있다. 이를 통해 바이트를 변환하는 SubByte, 행을 회전하는 ShiftRows, 각 컬럼에 대해 행렬곱셈을 수행하는 MixColumn의 과정으로 수행되며, 복호화는 반대 순서로 진행된다.
### RSA
* 비대칭키 암호화 방식으로, 공개키와 개인키 두 가지 키를 사용한다. 두 소수 p, q를 준비하고, p-1, q-1과 서로소인 정수 e를 준비한다. ed를 (p-1)(q-1)으로 나눈 나머지가 1이 되도록 하는 d를 아, N=pq인 N과 e를 공개한다. 이를 통해 암호화를 하며, d를 통해 복호화를 한다. 나머지 값은 파기한다.

## 문자열 인코딩에 대해 설명해 주세요.
* 사용자가 입력한 문자나 기호를 컴퓨터가 처리할 수 있는 신호로 변환하는 과정이다. 7비트의 아스키, Base64 등이 있다.
### Base64 인코딩은 일반적인 문자열 인코딩과는 달리, 사용자가 읽기 어려운 알파벳과 숫자 조합으로 변경합니다. 이를 사용하는 이유는 무엇일까요?
* Base64는 사용자가 읽기 위한 목적으로 하는 것이 아닌, 데이터의 전송을 목적으로 한다. 기존의 아스키는 7비트 형식으로, 시스템간 처리에 따라 안전하지 않을 수 있다. 그래서 6비트로 바꾸어 안전하게 전달 할 수 있다.

## P-NP문제란 무엇인가요?
* P집합과 NP집합이 같은지 다른지를 증명해야 하는 문제이다.
  * 같다: 모든 쉽게 검산 가능한 풀기 어려운 공식은 풀기 쉬운 공식으로 변형될 수 있다.
  * 다르자: 풀기 쉬운 공식으로 변형될 수 없는 어려운 문제가 하나라도 존재한다.
  * 증명할 수 없다.
### 해결된다면?
* 암호들은 NP문제이다. 하지만 P=NP라면, 이런 암호들은 더 이상 안전하지 않게 된다.
# 손코딩
