# 운영체제
### 운영체제의 역할은
* 자원관리 : CPU 스케줄링과 프로세스 관리, 메모리 관리, 파일 등 자원을 관리
* 자원 보호 : 프로그램이나 다른 사용자가 데이터를 삭제하거나 중요 파일에 접근하지 못하도록 자원을 보호
* 인터페이스 제공 : 하드웨어 인터페이스와 사용자 인터페이스를 제공하여 편리하게 사용하도록 지원
* 커널 : 컴퓨터 시스템의 핵심 부분으로, 하드웨어와 소프트웨어 사이의 중개자 역할을 함
## 메모리
### 메모리 계층
* 레지스터, 캐시, 주기억장치(RAM), 보조기억장치(SSD)
### 캐시 
* 데이터를 미리 볶사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
* 캐시의 지역성
  * 시간 지역성 : 최근 사용한것을 캐시에 넣음
  * 실제 OS단에서 가져가는 데이터는 4KB단위.. 그러므로 하나의 값만 참조해도 근처 값을 같이 가져오게된다. 그래서 공간지역성에 의한 캐시가 가능한것
### 메모리 할당
* 페이징
  * 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당합니다
* 세그멘테이션
  * 페이지 단위가 아닌 의미(논리)단위인 세그먼트로 나누는 방식
### 페이지 교체 알고리즘
* FIFO 
  * 가장 먼저 온 페이지를 교체영역에 가장 먼저 놓는 방법
* LRU (Least Recently Used)
  * 참조된지 가장 오래된 페이지를 바꿈
* LFU (Least Frequently Used)
  * 가장 참조 횟수가 적은 페이지를 교체
* 캐시에서도 적용할 수 있다.
## 프로세스와 쓰레드
### 프로세스
* 운영체제로부터 자원을 할당받아 실행되고있는 작업의 단위
### 스레드
* 하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위
### 프로세스와 스레드의 자원 구조
* 프로세스
  * 코드영역, 데이터영역, 스택영역, 힙영역을 할당받아 사용함
  * 데이터영역과 코드영역은 정적으로 할당되며 컴파일 단계에 할당됨
  * 스택과 힙 영역은 런타임 단게에서 동적으로 할당 됨
  * 스택은 지역변수, 매개변수, 함수에 따라 늘어나거나 줄어듦
  * 힙은 동적으로 할당되는 변수들이 담김
  * 스택메모리가 힙 메모리보다 더 빠른 접근이 가능함
* 스레드
  * 프로세스 내에서 다른 자원들은 공유하며, 별도의 스택영역만을 할당받음
### 컨텍스트 스위칭
* 프로세스(쓰레드)에서 다른 프로세스(쓰레드)로 전환하는 것. 프로세스의 상태를 저장하고 로드해야한다.
* 스레드는 스택영역을 제외한 모든 메모리를 공유하기 때문에 프로세스의 컨텍스트 스위칭보다 더 적은 비용과 시간을 소요한다.
## 공유자원과 임계영역
### 공유자원
* 시스템 안에서 각 프로세스, 스레드가 함께 접근 할 수 있는 자원이나 변수. 이 공유자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁상태라고 한다.
### 임계영역
* 둘 이상의 프로세스, 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드영역
### 뮤텍스, 세마포어, 모니터
* 이 세가지 방법을 통해 임계 영역을 해결 가능하다.
* 이 세가지 방법 모두 상호 배제, 한정대기, 융통성을 만족한다
* 상호 배제 : 한 프로세스가 임계영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다
* 한정 대기 : 특정 프로세스가 영원이 임계영역에 들어가지 못하면 안된다
* 융통성 : 만약 어떠한 프로세스도 임계영역을 사용하지 않는다면 임계영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 방해하지 않는다
* 뮤텍스
  * 공유 자원을 잠금 설정하여 사용 한 후 잠금 해제하는 방법(하나의 대상만이 자원에 접근 가능)
* 세마포어
  * 공유 자원에 대한 접근을 신호를 통해 제어. 카운트를 통해 진입 가능한 프로세스, 스레드의 수를 조절 가능하다

## 교착상태
* 교착상태(deadlock)는 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태이다.
### 교착상태의 원인
* 상호 배제 : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능
* 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
* 비선점 : 다른 프로세스는 자원을 강제적으로 가져올 수 없습니다.
* 환형 대기 : 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는, 서로의 자원을 요구하는 상황

### 교착상태의 해결 방법
* 예방 : 요구조건을 만족시키지 않게 함으로서 교착상태 방지, 자원 낭비가 심함
* 회피 : 교착상태가 발생할 가능성을 배제하지 않고 발생하면 적절히 피해나감, 교착상태가 발생할 가능성이 있는 자원할당을 하지 않음
* 탐지 및 회복 : 교착상태가 발생 하면 그 후 고침(프로세스 중지 등)

## CPU 스케줄링 알고리즘
* CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당합니다.
### 비 선점형 방식
* FCFS(선입선출)
  * 가장 먼저 온 것을 가장 먼저 처리하는(큐) 알고리즘
* 우선순위
  * 오래 된 작업일수록 우선순위를 높여 처리하는 알고리즘
### 선점형 방식
* 라운드 로빈
  * 현대 컴퓨터가 쓰는 알고리즘, 각 프로세스는 동일한 할당시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘.
  * 할당 시간이 너무 크면 FCFS에 수렴하고, 너무 짧으면 컨텍스트 스위칭이 잦아짐
* 다단계 큐
  * 우선순위에 따른 준비 큐를 여러개 사용하고, 큐마다 다른 스케줄링 알고리즘을 적용한 것.

## 멀티태스킹
### 동기와 비동기
* 요청한 작업에 대해 완료 여부를 신경써서 작업을 순차적으로 수행할지 아닌지에 대한 관전
  * 완료 여부를 기다리고 그를 다음 작업에 반영하므로 동기화됐다고 할수 있다
### 블로킹과 논블로킹
* 현재 작업이 블록(차단) 되느냐, 아니냐에 대한 관점
  * 논블로킹일 경우 현대 작업이 차단되지 않고(계속 작업하면서) 다른 작업을 수행

### 동기/비동기 + 블로킹/논블로킹 조합
* 동기 + 블로킹
  * 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고, 다른 작업의 완료 여부를 받아 순차적으로 처리하는 방식. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우 활용
* 비동기 + 논블로킹 방식
  * 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고, 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식
* 동기 + 논블로킹 방식
  * 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고, 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행 하는 방식
  * 사용예시로는 A 프로그램을 실행하는 도중 B 프로그램을 로드 할 때, A프로그램은 B프로그램의 로드하는동안의 진행률을 보여준다. 이로써 A프로그램은 자신의 작업을 처리하고있지만, B프로그램의 로드를 기다려야한다.

## 시스템 콜이 무엇인지 설명해 주세요.
* 운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램이 커널에 접근하기 위한 인터페이스. 운영체제에게 명령의 대행을 요청한다.
### 우리가 사용하는 시스템 콜의 예시를 들어주세요.
* open(), read(), write(), close(), fork(프로세스 생성), exec(현재 프로세스 대체), wait(프로세스가 자식 프로세스의 실행이 끝날 때 까지 기다리게 함), exit(프로세스 종료), kill(특정 프로세스 종료)
### 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
1. 응용 프로그램이 유저모드에서 시스템 콜 호출
2. 프로세스가 유저모드에서 커널 모드로 전환
3. 시스템 콜 번호 확인 및 처리
4. 유저모드로 복귀
### 시스템 콜의 유형에 대해 설명해 주세요.
* 프로세스 제어, 파일 조작, 장치관리, 정보 유지, 통신, 보호 등이 있다.
### 운영체제의 Dual Mode 에 대해 설명해 주세요.
* 시스템의 보안과 안정성을 유지하기 위해 유저모드, 커널모드라는 두 가지 모드를 사용하는 것.
* 유저모드 : 일반적인 응용 프로그램이 실행되는 모드. 제한된 접근 권한을 가지고 있어 시스템의 중요한 부분에 접근 할 수 없다.
* 커널 모드 : 운영체제의 커널이 실행되는 모드로, 시스템의 모든 자원에 대한 완전한 접근 권한을 가진다. 이 모드에서 시스템 콜이나 인터럽트 처리 등이 수행된다.
### 왜 유저모드와 커널모드를 구분해야 하나요?
* 시스템의 보안과 안정성을 유지하기 위해 유저모드를 두어 시스템의 중요한 부분에 접글 할 수 없도록 한다.
### 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
* 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유 번호를 할당하고 그 번호에 해당하는 제어 루틴을 커널 내부에 정의한다.

## 인터럽트가 무엇인지 설명해 주세요.
* 인터럽트란 예외상황이 발생하여 현재 실행 중인 작업을 즉시 중단하고 발생한 상황에 대한 우선 처리가 필요함을 CPU에 알리는 것이다.
### 인터럽트는 어떻게 처리하나요?
1. 인터럽트 요청을 받으면 현재 실행중인 상태를 중단한다.
2. 인터럽트 서비스 루틴으로 제어를 전환한다.
3. 이를 위해 CPU의 상태를 스택에 저장한다.
4. 인터럽트 처리를 한 후, 저장된 CPU 상태를 복원하고 중단된 프로그램의 실행을 계속한다.
### Polling 방식에 대해 설명해 주세요.
* 하나의 장치가 다른 장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 처리를 하는 방식.
### HW / SW 인터럽트에 대해 설명해 주세요.
* HW : 하드웨어 장치로부터 발생하여, 키보드 입력이나 네트워크 패킷 수신 등이 해당한다.
* SW : 특정 명령어의 실행에 의해 발생하며, 주로 운영체제의 시스템 콜을 처리할 때 사용된다. 혹은 0나누기 연산이나 잘못된 메모리 접근 등에서도 발생한다.
### 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
* 인터럽트 우선순위에 따라 진행하며, 현재 인터럽트가 처리중인데 더 높은 우선순위의 인터럽트가 실행되면 현재 인터럽트를 중단하고 새로운 인터럽트를 처리하고, 이후 이전의 인터럽트를 처리하게 된다.

## 프로세스가 무엇인가요?
* 컴퓨터에 의해 실행되고 있는 프로그램.
### 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
* 프로그램 : 코드의 집합, 디스크 안에 저장되어있다.
* 프로세스 : 실행 중에 있는 프로그램, 운영체제로부터 실행에 필요한 자원을 할당받은 상태. 독립적인 code, data, stack, heap 메모리 공간을 가지고 있음
* 쓰레드 : 프로세스 내에서 실행되는 여러 흐름의 단위
### PCB가 무엇인가요?
* Process Control Block : 운영체제가 프로세스를 제어하기 위해 정보를 저장해놓은 곳. 프로세스가 생성될 때 마다 고유의 PCB가 생성된다. 프로세스의 상태관리와 context swiching을 위해 필요하다.
### 그렇다면, 스레드는 PCB를 갖고 있을까요?
* 쓰레드는 별도의 PCB를 가지고 있지 않아.
### 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
* 프로세스 : fork()를 통해 자식 프로세스 생성, exec()을 통해 다른 작업으로 변경
* pthread_create()를 통해 프로세스 생성
### 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
* 고아 프로세스 : 부모 프로세스가 자식 프로세스보다 먼저 죽은 경우
  * 프로세스가 죽을 때 해당 프로세스가 어떤 프로세스의 부모 프로세스인지 확인 후 init 프로세스로 부모 프로세스를 옮김
* 좀비 프로세스 : 자식 프로세스가 부모 프로세스가 먼저 죽은 경우
  * 커널은 자식 프로세스가 종료 프로세스 테이블에 여전히 남아있으며, 부모 프로세스가 wait() 을 통해 종료상태를 회수하면 좀비 프로세스가 제거된다.
### 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
* 사용자의 직접적인 개입 없이 백그라운드에서 실행되며 특성 서비스를 제공하는 프로세스. 시스템이 부팅될 때 자동으로 시작된다. 리눅스에서는 `httpd`, `sshd`, `msqld` 등이 있다.
### 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
* 시스템 부팅 시 가장 먼저 시작되는 프로세스, `init` 또는 `systemd`이다.
##  프로세스 주소공간에 대해 설명해 주세요.
* 프로세스가 운영체제로부터 할당받는 메모리 영역
* code : 프로그램의 명령어들이 위치하는 공간, 컴파일시 결정됨
* data : global, static 변수가 저장되는 영역으로 프로그램 실행 동안 지속적으로 유지되어야 하는 데이터, 컴파일시 결정됨
* stack : 함수의 호출과 반환에 사용되며, 매개변수, 반환주소 등이 저장된다. LIFO 방식으로 관리된다. 컴파일시 결정된다.
* heap : 프로그램 실행 중에 동적으로 할당하고 해제 할 수 있는 메모리 영역. 런타임중에 필요에 따라 할당되고 해제되며, 낮은 주소에서 높은 주소의 방향으로 할당된다. class와 class의 객체들이 이곳에 저장된다.(참조값)
### 초기화 하지 않은 변수들은 어디에 저장될까요?
* BSS(Block started by symbol)영역에 저장된다.
### 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
* 편의상 그렇게 그렸지만, 프로그램에 따라 그렇지 않을 수 있다. 스택은 컴파일시 정해지며, 힙은 필요에 따라 동적으로 할당된다.
### Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
* Cpu가 직접 관리하고 최적화 하기 때문에 stack이 빠르다.
### 다음과 같이 공간을 분할하는 이유가 있을까요?
* 메모리 관리의 효율성과 안정성을 높이기 위해 사용되며, 데이터를 공유하여 메모리 사용량을 줄일 수 있다.
### 스레드의 주소공간은 어떻게 구성되어 있을까요?
* 프로세스 내에서 각각의 스택만 할당 받고 나머지 영역은 공유한다.
### "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
* 스택영역은 실제 자료구조의 스택과 같은 방식인 LIFO로 작동한다.
* 힙 영역은 실제 자료구조 힙과 큰 관련이 없다.
### 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
* 스택 영역은 컴파일시, 힙 영역은 런타임시에 동적으로 결정된다. 힙 영역은 사용자가 직접 할당하고 해제할 수 있다. 특정 환경에서는 사용자가 스택의 크기를 변경할 수 있으나, 신중하게 수행되어야 한다.

## 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.
* 단기 : 준비 상태의 프로세스를 다음번 실행상태로 만들 것인지 결정하는 스케줄러.
* 중기 : 스와핑 스케줄러라고 불리며, 시스템의 성능 저하를 방지하기 위해 메모리에 적재된 프로세스 수를 조절합니다.
* 장기 : 시스템에 새로운 프로세스를 언제 도입할지 결정. 수십 초에서 수분 단위로 작동 할 수 있다.
### 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?
* 현대에는 장기 스케줄러는 사용하지 않는다. 메모리 크기 증가와 가상 메모리 관리 기술에 따라 메모리 사용이 원활해 졌기 때문.
### 프로세스의 스케쥴링 상태에 대해 설명해 주세요.
* Created : 프로세스가 생성되었지만, 아직 준비 큐에 들어가지 않은 상태
* New : 생성 후 준비 중인 상태
* Ready : 프로세스가 준비가 완료된 상태 CPU 할당을 기다리는 상태
* Running : 프로세스가 CPU를 할당받아 명령어를 실행하고 있는 상태
* Wating : 프로세스가 대기중인 상태
* Suspended : 프로세스가 메모리자원이 부족하여 스왑 아웃되어 디스크에 저장된 상태
* Terminated : 프로세스가 실행을 완료하고 제거된 상태
### preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
* 선점적 스케줄링 : 운영 체제가 실행 중인 프로세스를 언제든 상태가 변화 될 수 있다.
* 비선점적 스케줄링 : 실행 중인 프로세스는 선점되지 않으며, 다른 프로세스가 CPU를 해제할 때 까지 기다려야한다. 그러므로 실행에서 준비로 돌아가지 못한다.
### Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?
* Suspened 상태로 변화되어 스왑 아웃돼 디스크에 저장된다.
