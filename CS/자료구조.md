# 자료구조

## 선형 자료구조

### 배열(Array)
* 같은 타입의 변수들로 이루어져 있으며, 크기가 정해져 있고 인접한 메모리 위치에 있는 데이터를 모아놓은 집합. 접근에 O(1), 삽입과 삭제에 O(n)의 시간이 걸린다.

### LinkedList
* 삽입과 삭제에 효과적인 자료구조. 하지만 탐색에 O(n)의 시간이 걸린다

### ArrayList(Vector)
* 자바에서 ArrayList와 Vector는 동일한 작업에 쓰이지만, 동기화 여부의 차이로 벡터는 Treadsafe하고, ArrayList는 그렇지 않다.
* ArrayList의 내부는 배열로 이루어져 있으며, 현재 할당된 공간이 모두 차면 크기를 2배로 늘린 후 늘어난 배열에 복사한다.
  * 2배로 늘리는 이유는 성능과 메모리 사용량간의 균형을 유지하기 위함이다.
  * 반대로 요소의 개수가 줄어들 때에, ArrayList는 배열의 크기가 줄어들지 않고 Vector는 1/4시점에서 절반으로 줄어든다.
### 스택
* 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO)을 가진 자료구조.
* 삽입 및 삭제에 O(1), 탐색에 O(n)

### 큐
* 가장 먼저 들어간 데이터가 가장 첫 번째로 나오는 성질(FIFO)을 가진 자료구조.
* 삽입 및 삭제에 O(1), 탐색에 O(n)

스택과 큐는 모두 기본적으로 링크드 리스트로 구현되어있다.

## 비선형 자료구조

### 맵
* 키와 값으로 매핑된 조합. 정렬을 보장하지 않는 unorderd_map과 정렬을 보장하는 orderd_map이 있다.
* 자바에서는 HashMap, LinkedHashMap, ConcurrentHashMap이 있고 sortedMap으로 TreeMap이 있다.
* 해시 충돌시에 자바는 Chaining을 통해 해당 위치에 링크드리스트나 트리로 저장하고, 파이썬은 OpenAddressing으로 함수를 다시 적용하여 다른 위치에 저장함으로써 해결한다.
* 내부 배열(버킷)의 크기는 3/4만큼 찬 시점에서 두배로 늘린다.

### 셋
* 고유한 요소를 저장하는 집합. 중복이 없다.
* 맵과 같이 unordered_set과 orderd_set이 있다.

# 심화 질문

## 시간복잡도와 공간복잡도에 대해 설명해 주세요.
* 시간복잡도는 알고리즘이 수행되는 시간, 공간 복잡도는 그 때 차지하는 공간을 의미한다.
### Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.
* O는 최악의 경우, 세타는 상한과 하한의 중간, 오메가는 최선의 경우 하한이다.
### 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?
* 알고리즘은 최악의 경우를 상정해야 하기 때문이다.
### O(1)은 O(N^2) 보다 무조건적으로 빠른가요?
* 그렇지 않다. 예를 들어 N이 2이고 상수가 없는 경우, N^2여도 4지만 O(1)이더라도 상수계수가 높은 경우 더 느릴수도 있다.

## 링크드 리스트에 대해 설명해 주세요.
* 배열과 같이 여러개의 값을 연속해서 이어놓은 자료구조지만, 인접 주소가 아닌 하나의 노드가 값과 다음 노드의 주소를 가지고 있어 노드끼리 이어진 자료구조이다. 각 노드의 주소를 알 수 없으므로 검색에는 O(N)이 걸리고, 삭제나 삽입시에는 O(1)이 걸린다.
### 일반 배열과, 링크드 리스트를 비교해 주세요.
* 일반 배열 : 값들이 연속된 주소를 가진다. 그렇기에 접근시에는 특정 값의 주소를 알 수 있기에 O(1)이 걸린다. 또한 값들이 연속된 주소를 가지기에 공간 지역성에 따라 순회가 훨씬 빠르다. 하지만 값을 중간에 삽입하거나, 중간의 값을 삭제할 때에는 해당 값 이후의 모든 값들을 뒤로 밀거나 당겨야하므로, O(N)의 시간이 걸린다.
* 링크드 리스트 : 값들이 랜덤한 주소를 가지고, 다음 주소의 값을 현재 노드가 가지고 있다. 그렇기에 순회시 캐싱을 활용할 수 없어 조금 더 느리고, 특정 노드에 한번에 접근 할 수 없다. 하지만 값을 중간에 삽입하거나 삭제할 때에는 이전 노드의 주소와 다음 노드의 주소만 알면 되므로 O(1)에 가능하다.
### 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.
* 스택 : 각 노드는 이전 노드의 주소를 가진다. 그리고 가장 최근에 넣어진 노드의 주소에 접근 할 수 있는 메서드를 넣어, 가장 최근의 값을 확인하거나 제거, 또는 새로운 값을 삽입할 때 O(1)의 시간으로 작동하도록 할 수 있다.
* 큐 : 각 노드는 다음 노드의 주소를 가진다. 그리고 가장 오래된 노드의 주소와 가장 최근 노드에 접근 할 수 있는 메서드를 넣어, 가장 오래된 값을 확인하거나 제거할 때 오래된 노드, 새로운 노드를 삽입 할 때 최근노드에 접근할 때 O(1)의 시간복잡도에 작동하도록 할 수 있다.
* 그 외에 이중링크드리스트, 덱 등을 구현 할 수 있다.

## 스택과 큐에 대해서 설명해 주세요.
* 스택 : LIFO, 가장 나중에 넣은 값이 먼저 나오는 자료구조. 바구니와 같다.
* 큐 : FIFO : 가장 처음에 넣은 값이 먼저 나오는 자료구조. 터널과 같다.
### 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.
* 스택 2개로 큐 : 넣기만 하는 스택, 빼기만 하는 스택을 만든다. 넣을 때는 넣기만 하는 스택에 정상적으로 넣는다. 넣을 때는 O(1)이다. 뺄 때는, 빼기만 하는 스택에서 하나씩 뺀다. 이 때, 빼는 스택이 비어있다면 넣기만 하는 스택해서 값을 순차적으로 빼서 하나식 빼기만 하는 스택에 넣는다. 그 뒤 빼면, FIFO를 만족할 수 있다. 이 때의 시간복잡도도 평균적으로 O(1)이다.
* 큐 2개로 스택 : 큐 A와 B를 번갈아가며 사용한다. A에 값을 넣는다. 이 때 O(1)의 시간이 든다. 뺄 때는 A의 값을 하나를 제외하고 B에 넣는다. 그리고 A의 값을 빼면 가장 마지막에 넣은 값을 뺄 수 있다. 이 때 시간복잡도는 O(N)이다. 이후 A와 B의 역할을 바꿔가면서 사용하면 된다.
### 시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?
* 매우 큰 배열을 사용하면 배열이 꽉 차기 전까지는 스택과 유사하게 사용 할 수 있다. 배열중 가장 마지막 값을 삭제 하거나, 마지막 값 뒤에 값을 하나 추가하는데에는 시간 복잡도가 0이기 때문이다. 하지만 배열이 꽉 찬 경우 불가능해진다.
* 배열의 가장 처음을 가리키는 포인터를 사용해 구현 할 수 있다. poll 연산이 일어나는 경우 head 인덱스를 하나씩 당겨오는 방식으로 구현 할 수 있다. 다만 연산이 이루어지면서 점점 사용할 수 있는 범위가 작아진다.
### Deque는 어떻게 구현할 수 있을까요?
* 이중 링크드 리스트를 사용하면 덱을 구현 할 수 있다.
### (C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?
* 여러개의 고정크기를 가진 배열로 이루어져있다. 각 배열들은 중앙 인덱스 맵에 저장된다. 이를 통해 random access가 O(1)로 이루어 질 수 있다.

## 해시 자료구조에 대해 설명해 주세요.
* key와 value로 구성되며, key를 해싱하여 나온 값을 가진 인덱스에 value를 저장한다. 내부의 해시 버킷은 벡터로 이루어진다. 값의 조회와 삽입, 삭제에 O(1)의 시간을 가진다.
### 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
* 전체 값이 해시 결과에 영향을 끼쳐야한다. 키의 일부만이 영향을 끼칠 경우, 해시 충돌이 일어날 확률이 높다. 또한 테이블 전체에 걸쳐 균등하게 키의 해싱 값이 분포되어야 한다.
### 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?
* Open addressing : 충돌이 일어난 경우, 충돌이 일어나지 않을 때 까지 다시 해시함수를 적용하거나, 다음 칸을 탐사하여 빈 곳에 값을 넣는다. 이 방법을 사용하면 최악의 경우 O(N)의 시간복잡도를 가질 수 있다. 하지만 별도의 메모리 소모를 하지 않는다.
* Chaining : 충돌이 일어난 노드에서 링크드리스트나 트리를 만들어 해결한다. 트리를 사용하면 최악의 경우에서 O(logN)의 시간을 가지지만, 추가적인 메모리를 사용하게 된다.
### 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?
* Java에서는 체이닝을 사용한다. 링크드 리스트의 개수가 8개 이상이면 레드블랙 트리로 전환되고, 6개 이하가 되면 다시 링크드리스트로 전환된다.
* Python에서는 오픈어드레싱을 사용한다. 이 때, Linear Probing 방식을 사용한다.
### Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.
* 오픈 어드레싱 방법중 하나로, 두 개의 해시 함수를 사용한다. 충돌이 일어나는 경우, 두 번째 해시함수로 구한 값을 사용해 다른 차리를 찾는다. 이로 인해 해시 충돌이 줄어들고, 군집화가 감소한다. 하지만 캐시 효율이 좋지 않고, 계산을 위한 추가적인 메모리 소모가 생길 수 있다. 해시 테이블 크기의 적절한 관리를 통해 캐시 효율을 개선할 수 있다.
### Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?
* Java는 로드팩터 기본값이 0.75로 설정되어 있다. 파이썬은 0.66으로 지정되어있다.
### 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.
* 쓰레드간에 락을 걸어 동기화 할 수 있지만. 이 방법은 성능이 크게 감소한다. 그러므로 해시테이블을 여러개의 세그먼트 나누어, 각 버킷의 필요한 세그먼트만 락을 걸어서 이러한 성능 감소를 최소화 할 수 있다.

## 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.
* 트리 : 노드와 간선으로 이루어져있고, 사이클이 존재하지 않고 노드가 모두 연결되어 있어야 한다.
* 이진 트리 : 자식노드를 최대 2개만 가지는 트리.
* 이진 탐색 트리 : 이진 트리 중 왼쪽 자식 노드는 자신보다 작고, 오른쪽 자식 노드는 자신보다 큰 값을 가진다.
### BST 의 succesor란?
* 해당 노드에서 가장 가까운 값을 가진 노드.
* 해당 노드가 오른쪽 자식을 가지는 경우, 그 오른쪽 노드의 가장 왼쪽 리프노드가 succesor가 된다.
* 해당 노드가 오른쪽 자식을 가지지 않는 경우, 조상 노드중 처음으로 왼쪽 노드를 가지는 노드의 부모가 succesor가 된다.
### 그래프와 트리의 차이가 무엇인가요?
* 노드와 간선으로 이루어졌다면 모두 그래프이다. 이런 그래프중 사이클을 가지지 않으면서 노드끼리 모두 연결되어 있다면 트리이다.
### 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?
* 이진 탐색 트리는 왼쪽 > 루트 > 오른쪽 순으로 탐색한다. 이진 탐색 트리는 `왼쪽 < 루트 < 오른쪽` 순의 크기를 가지므로 오름차순 정렬이 된다.
### 이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.
* 모두 O(logN)이다.
* 검색 : 타겟 데이터가 존재하는지 찾기 위해, 현재 노드와 비교하여 작으면 왼쪽, 크면 오른쪽으로 찾는다.
* 삽입 : 새로운 데이터를 삽입할 위치를 찾기 위해, 해당 노드보다 작으면 왼쪽, 크면 오른쪽으로 탐색하여 삽입한다.
* 삭제 : 삭제할 데이터를 탐색하여 찾은 후, 오른쪽 서브트리의 최소값이나 왼쪽 서브트리의 최대값을 끌어올린다.
* 하지만 트리가 선형에 가까운 경우. O(N)의 시간복잡도가 나올 수 있다.
### 이진탐색트리의 한계점에 대해 설명해주세요.
* 트리가 균등하게 분포하지 않는 문제가 생길 수 있다. 한 쪽으로 치우진 경우 O(N)의 효율이 나올 가능성이 존재한다.
### 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?
* 정렬된 데이터를 순서대로 삽입 할 경우 편향이 발생한다. 오름차순 데이터를 삽입 할 경우 우편향, 내림차순 데이터를 삽입할 경우 좌편향이 발생한다.
### 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.
* 동일한 로직으로는 만들 수 없다. 3개의 자식 노드 중 자신보다 작은 노드, 큰 노드 2개를 제외한 1개의 노드에 대한 추가적인 규칙을 만들어야한다.

## 힙에 대해 설명해 주세요.
* 완전 이진트리를 기반으로 하며, 우선순위가 높은 값을 찾기 위한 자료구조이다. 부모노드가 항상 자식노드보다 높은 우선순위를 가지는 자료구조이다. 검색, 삽입, 삭제에 O(logN)의 시간을 가진다.
### 힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?
* 1번 노드부터 시작해 `N*2`번째 노드에 왼쪽 자식의 값, `N*2+1`번째 노드에 오른쪽 자식의 값을 삽입할 수 있다.
### 힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.
* 삽입시에는 새로운 요소를 힙의 마지막 노드로 추가한다. 새 노드와 부모 노드를 비교하며, 부모노드보다 우선순위가 높은 경우 교체하는 것을 반복한다.
* 삭제시에는 우선순위가 가장 높은 값을 삭제한 후, 가장 마지막 노드의 값을 루트노드로 올린다. 이후 자식노드와의 비교를 통해 우선순위가 낮은 경우 교체하는 것을 반복한다.
### 힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?
* heap 정렬의 시간 복잡도는 O(NlogN)이다. 노드 하나를 삽입 할 때마다 logN의 시간이 걸리고, 이 것을 N번 반복하기 때문이다. 힙 정렬시에는 원소들의 위치가 여러 번 바뀌어 기존 순서가 보장되지 않기에, 불안정 정렬이다.

## BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.
* 균형 이진 탐색트리, 이진 탐색 트리에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이를 유지하는 특성을 가진다.
* Red Black Tree
  * 자가 균형 이진트리이다.
  * 트리의 모든 노드는 레드 or 블랙이다
  * nil노드(존재하지 않음을 의미하는 노드)가 존재한다.leaf노드는 항상 nil노드이며, 값이 있는 노드와 동등하게 취급하며, 블랙이다.
  * 루트노드가 블랙으로 시작하며, 루트노드에서 리프노드까지 블랙노드의 개수는 항상 같다.(자신 제외) 블랙노드의 자식은 블랙or레드이고, 레드노드의 자식은 블랙이다(레드노드는 연속으로 존재할 수 없다). 그렇기에 가장 긴 경우인 블랙과 레드가 번갈아 있는 경우와 가장 짧은 경우인 블랙만 있는 경우가 2배 이하로 차이가 난다.
  * 삽입 과정 : 새 노드(N)를 레드로 칠하고, 일반적인 이진 탐색 트리의 과정을 따라 리프위치에 삽입한다. 이때, 부모가 레드이면 해결하는 과정을 거친다.
  * 해결 과정 : 문제가 생긴 노드를 N이라고 한다 .
    * N이 루트인 경우 : N을 블랙으로 칠하고 종료한다.
    * N의 부모가 레드 : 이 경우 위반이 발생하므로, 해결과정을 거친다.
      * 삼촌(부모의 형제) : 가 레드인 경우 : 부모와 삼촌을 블랙으로 바꾸고, 조부모를 레드로 바꾼다. 조부모가 레드가 되어 다시 위반되었다면, 다시 이 해결과정을 거친다.
      * 삼촌이 블랙 
        * 새 노드가 바깥쪽 자손인 경우 : 조부모, 부모의 색을 바꾼 후 조부모를 시준으로 안쪽으로 회전을 한다. 
        * 새 노드가 안쪽 자손인 경우 : 부모를 기준으로 바깥쪽으로 회전 한 후, 부모를 바깥쪽 자손으로 만들어 다시 진행한다.
  * 삭제 과정
    * 삭제하려는 노드의 자식이 없는 경우 : 그냥 삭제한다.
    * 하나인 경우 : 삭제 후, 부모노드와 자식노드를 연결한다.
    * 두개인 경우 : succesor를 찾아 삭제할 노드와 교체하고, 삭제하려는 노드를 삭제한다.
    * 이 과정에서 블랙의 수가 같지 않게 된 경우, extra black 을 부여하여 검정 노드 수를 하나 늘리며, 이후 조정 과정을 거치며 extra black 을 제거한다.
  * 리눅스 커널, 자바 트리맵, C++ 맵 등에 쓰인다.
* ABL 트리 : 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하로만 난다. 삽입/삭제시마다 트리를 회전시켜 균형을 맞춘다.
  * 삽입/삭제가 거의 없고 검색이 대부분인 상황에서 사용
* ABL트리는 레드블랙 트리와 비교해 루트 노드까지 가서 밸런스 팩터를 확인하기에 삽입/삭제가 더 느리고, 검색성능은 AVL트리는 균형이 더 엄격하기에 검색 성능이 더 빠르다.
### Red Black Tree는 어떻게 균형을 유지할 수 있을까요?

### Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.
* 모든 노드는 레드나 블랙이다
* 루트노드는 black이다
* 모든 nil 노드는 black이다.
* 레드노드는 연속할 수 없다.
* 임의의 노드에서 리프노드까지의 black 수는 같다.
### 2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?
* 234 트리는 실제 구현이 어렵고, 레드블랙트리는 상대적으로 쉬운 구현 방법을 가진다. AVL트리와 비교했을때는 실제 환경에서는 삽입/삭제상황이 많이 일어나기에 이에 적절한 레드블랙트리를 사용한다.

## 정렬 알고리즘에 대해 설명해 주세요.
* 자료구조에서 데이터를 정렬하는 방법. 퀵소트, 머지소트, 버블소트, 삽입소트 , 팀소트 등이 있다. 정렬 알고리즘을 선택 할 때, 해당 정렬알고리즘의 시간복잡도, 추가적인 메모리 사용, 안정정렬인지 등을 고려해서 선택하게 된다.
### Insertion Sort에 대해 설명해주세요.
* 왼쪽에 있는 수들과 비교해 내가 들어갈 자리를 찾아 갈 수 있다. 이 때 내가 찾아갈 자리를 이진탐색을 통해 찾아, 시간을 조금 더 절약 할 수 있다.
### Quick Sort와 Merge Sort를 비교해 주세요.
* 둘 모두 분할정복 알고리즘을 사용한다.
* 퀵 정렬은 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 파티션을 분할한다. 이 과정에서 배열 내에서 투포인터 방식으로 위치를 바꾸기에 캐시 히트율이 좋고, 한번 피벗으로 설정된 수의 위치는 고정되기에 속도가 매우 빠르다. 하지만 특정 데이터에서 피벗과 데이터의 정렬 여부에 따라 N^2의 속도가 나올 수 있는 단점이 있고, 객체의 위치가 계속해서 바뀌기에 기존 순서를 유지하지 않는 불안정 정렬의 특징을 가진다.
* 머지소트는 배열을 절반으로 나눈 새로운 배열을 나눌 수 없을 때 까지 만든다. 이후 두 배열을 확인하며 우선순위대로 합친다. 이 때 새로운 배열을 만드므로 메모리 소모가 많지만, 기존의 순서를 보장하므로 안정정렬이고 최악의 경우에도 NlogN의 시간을 가진다. 
### Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.
* 퀵소트에서 일반적으로 가장 첫번째 값을 피벗으로 설정하는데, 이 때 정렬이 이미 되어있는 데이터라면 분할이 이루어지지 않기에 N^2의 시간이 걸린다. 이를 해결하기 위해 피벗을 두 개 설정하는 dual pivot quick sort를 사용하면 어느정도 개선 가능하다.
* 피벗을 두개 설정에 삼분할을 한다.
### Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.
* 데이터를 정렬 할 때, 정렬 조건이 같은 경우 기존의 순서를 유지하는 경우를 stable 정렬이라고 한다.
* 머지소트 : 버블정렬, 삽입정렬, 병합정렬 등이 있다.
* 불안정 정렬 : 힙정열, 퀵정렬 등이 있다.
### Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?
* 재귀를 사용하지 않더라도 반복문을 통해 상향식으로 접근 할 수 있을 것 같다.
### Radix Sort에 대해 설명해 주세요.
* 자릿수가 있는 데이터에서 사용 할 수 있는 정렬이다. O(kN)의 시간 복잡도를 가진다. 데이터를 직접적으로 비교하기 않고, 자리수에 대해서 정렬을 하는 방법이다. 자리수가 매우 적거나, 매우 많은 경우 오히려 성능이 다른 정렬 알고리즘에 비해 안좋아질 수 있다.
### Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.
* 시간복잡도는 모두 O(n^2)이다. 하지만 삽입정렬은 이진탐색의 활용, 정렬된 데이터에서의 빠른 속도 등으로 비교적 빠른 속도를 가진다. 버블정렬은 정렬되어있는 경우를 제외하곤 성능이 좋지 않다. 선택정렬은 일반적으로 버블정렬보단 빠르지만, 정렬되어 있더라도 O(N^2)의 시간을 가진다. 하지만 이는 자료구조에 따라 달리질 수 있다.
### 값이 거의 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?
* 버블정렬과 삽입정렬은 거의 정렬되어 있는 경우에 O(N)에 가까운 시간복잡도를 가진다. 선택정렬은 그렇지 않다.
### 본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?
* 자바에서 premitive타입에선 퀵소트, 그 외 객체에선 팀소트를 사용한다. 
### 정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?
* 병합정렬을 사용하여, 데이터의 일부분씩 정렬해볼 수 있을 것 같다.

## 그래프 자료구조에 대해 설명하고, 이를 구현할 수 있는 두 방법에 대해 설명해 주세요.
* 노드와 간선의 연결 이루어진 자료구조.
* 인접행렬과, 인접 리스트로 구현 할 수 있다.
### 각 방법에 대해, "두 정점이 연결되었는지" 확인하는 시간복잡도와 "한 정점에 연결된 모든 정점을 찾는" 시간복잡도, 그리고 공간복잡도를 비교해 주세요.
* 정점의 개수 E, 간선의 개수 V
* 인접 행렬은 두 정점이 연결되었는지에서는 O(1)로 확인 할 수 있고, 한 정점에 연결된 모든 정접을 찾을 때는 배열을 모두 순회해야하므로 O(E)의 시간복잡도가 든다. 
* 인접 리스트는 링크드 리스트를 쓸 경우 O(V), O(V), 어레이리스트는 O(V), O(V)이다. 하지만 어레이리스트를 쓸 경우 동적으로 할당하는 경우에 추가적인 비용이 발생할 수 있다.
* 그리고 이차원배열은 O(E^2)의 공간 복잡도를, 연결리스트는 O(E+V)의 공간복잡도를 가진다.
### 정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 방식으로 구현하는 것이 효율적일까요?
* 간선이 많으므로 인접 행렬이 더 효율적이다. 중복된 간선을 인접 행렬에서 개수로 표현 할 수 있을 것 같다.
### 사이클이 없는 그래프는 모두 트리인가요? 그렇지 않다면, 예시를 들어주세요.
* 그렇지 않다. 사이클이 없더라도, 그래프끼리 연결되지 않은 노드가 있을 경우 트리가 아니다.

## Thread Safe 한 자료구조가 있을까요? 없다면, 어떻게 Thread Safe 하게 구성할 수 있을까요?
* 자료구조 내의 메서드들에서 락을 걸어 다른 스레드가 접근하지 못하게 함으로써 구현 할 수 있다. 하지만 이는 메서드 동작간에만 Thread safe 할 뿐, 해당 메서드가 끝나면 바로 다른 쓰레드에서 접근 할 수 있다. 일부 immutable 한 객체는 항상 thread safe 할 수 있을것이고, 그 외에도 작업 단위에 동기화를 함을 통해서 다른 쓰레드가 접근 할 수 없게 할 수 있을것이다.
### 배열의 길이를 알고 있다면, 조금 더 빠른 Thread Safe 한 연산을 만들 순 없을까요?
* 배열중 일부에만 잠금을 하여서 전체를 잠글때보다 조금 더 다른 스레드가 접근하기 쉽게 할 수 있을 것이다.
### 사용하고 있는 언어의 자료구조는 Thread Safe 한가요? 그렇지 않다면, Thread Safe 한 Wrapped Data Structure 를 제공하고 있나요?
* 몇몇 자료구조가 thread safe한 메서드들을 제공한다. Hashtable, Vector, ConcurrentHashMap, BlockedQueue 등이 있다. `Collections.synchronizedList`나 `Collections.synchronizedMap` 를 통해 thread safe하지 않은 자료구조에도 `synchronized` 키워드를 통해 thread safe를 보장 할 수 있다.

## 메모리에 한번에 올릴 수 없는 매우 많은 데이터를 정렬할 때는 어떻게 해야할까요?
* 분할정복 방식을 사용한다. 메모리만큼 데이터를 읽어 온 후, 내부 정렬을 이용해 데이터를 정렬한다. 정렬된 데이터를 보조 기억 장치에 기록한다. 이후 정렬된 블록들을 병합하는 절차를 반복 수행한다. 블록들을 부분적으로 메모리에 읽어들이며 보조 기억 장치에 다시 입력하는 과정을 거친다.
### 한 컴퓨터에 모두 저장하지 못할 정도로 많은 데이터를 어떻게 정렬할 수 있을까요?
* 보조 정렬, 부분 정렬, 전체 정렬을 사용한다. 
* 보조 정럴: 키의 값들을 그룹핑하고, 그룹핑된 레코드에 순서를 부여한다.
* 부분 정렬: 정렬할 파일을 맵 단계서 시퀀스 파일로 출력을 해주고, 출력된 시퀀스 파일을 맵 파일로 변경한 후 맵파일에서 원하는 데이터를 검색해내는 방법.
* 입력 데이터를 샘플링해서 데이터의 분포도를 조사하고, 데이터의 분포도에 맞게 파티션 정보를 미리 생성한다. 미리 생성한 파티션 정보에 맞체 출력 데이터를 생성한다. 이후 출력 데이터를 병합한다.
