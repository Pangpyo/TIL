# 레디스
## 레디스 왜 써야할까?
* Redis vs HashMap... 뭐가 빠를까?
  * 당연히 맵이 빠르다! 통신시간이 있기때문
### Local Cache Shared Cache
* L1 L2 는 로컬, L3는 Shared
* 서버가 여러개라면 각 서버의 캐시를 로컬캐시, 여러개의 서버에서 공유하는 캐시를 레디스로 볼수 있겠다

### Hazelcast 
* 한 개의 데이터를 최소 2개의 노드에 적재하고 있는 구조.
  * 로컬캐시지만 SharedCache처럼 동작
  * 조회시에는 레디스보다 빠르지만 쓸때는 2개의 노드를 모두 갱신해야하므로 느려짐.

* 레디스는 다른 컴포넌트에 비해 불안정하고 위험한 컴포넌트가 될 수 있다(인메모리 특성상)

## 레디스 구조
* CPU의 부하가 적을 것이라고 상정되어서 만들어졌으므로, 싱글 코어 구조를 가지고 있다.
* 싱글스레드라고 하지만, 싱글스레드는 아니다?
  * 백업스레드를 사용하긴 하기때문에!

### I/O Multiplexing
* 다수의 쓰레드는 과도한 Context Switching의 원인이 되고, 성능 저하로 이루어질 수 있다.
* 소켓 역시 파일이므로, 하나의 쓰레드가 관리할 수도 있다.
* 그래서 레디스가 싱글쓰레드로 가능
  * 사실 이제는 싱글쓰레드가 아니다...

### 레디스 메모리 최적화
* 데이터의 수가 충분히 적으면 인트셋, 많으면 HashTable 사용 (충분히 적은 경우 성능을 일부 희생하고 메모리 최적화를 하는 것)
* 캐시 미스가 늘어나면 성능이 줄어드므로, 데이터가 잘 히트되게 넣고, 덜 히트되는 데이터를 뺴야한다
* 캐시의 시간 지역성이나 공간 지역성을 활용할 수 있을까?
  * 우리가 Redis 메모리를 통제할수는 없으므로 지역성을 활용하기는 어렵다
* 모든 데이터를 전부 캐시화시킬 필요는 없고, 특성 시간대/전체적으로 반복되는 호출되는 데이터를 고려
* 특정 시간대에만 자주 참조되는 데이터의 경우, 적절한 TTL을 설정해야한다.

### TTL
* 1234, 1235, 1236 > 1235에 모두 지워도 비슷하다.
* 사실 접근하기 전까지 안지워도 된다.
* 하지만 평생 지워지지 않을 수 있으므로, 레디스 내부적으로 랜덤접근을 통해 지운다.
* LRU알고리즘을 주로 사용한다. (실제로는 LRU 근사 알고리즘. 링크드 리스트를 사용해 구현하면 오히려 메모리 사용량이 늘어나므로)

## 연산의 시간복잡도
* KEYS : 시간복잡도 N.. 위험하다!
* 대신 SCAN을 사용! 페이징을 사용해 속도를 향상시킨다.

## 백업
* AOF : 입력한 CRUD 정보를 기록
  * 빠른 백업, 느린 복구속도
* RDB(Redis Database) : 특정 시점의 데이터를 export
  * 실시간 백업 불가능, 레디스 성능 저하. 덤프 크기가 작고 복구 속도가 빠름.
  * save와 bgsave
    * save는 블로킹 발생

* CRUD가 들어오는 마스터는 AOF, R만 들어오는 Slave에서는 RDB로 백업
  * 마스터는 AOF로 백업하다가, 새로운 slave가 생기면 RDB로 만들어서 전달한다.
* client-output-buffer-limit
  * 마스터에 예상치 못한 높은 부하 발생시, Master에 장애가 발생해도 Slave에 번지지 않도록 한다

## 클러스터링
* 데이터를 나눠서 저장 할 수 없을까? 어떤 기준으로 해야할까?
* 해시값을 기준으로 세개로 나누고, 각각의 나뉜 서버가 각각의 슬레이브를 가진다.
  * 특정 데이터들을 같은 서버에 두고싶은 경우, 해시함수를 통해 해결할수 있다. 다만 이 경우 데이터 불균형이 올 수 있음을 주의하자.
* ADDSLOTS/DELSLOTS
  * 서버대수에 변경이 있을 경우 각 해시범쉬에 따른 데이터를 재배열해야한다. 운영중에는 하지 말자.